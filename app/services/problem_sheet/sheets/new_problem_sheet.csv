ID,PROBLEM,URL,DESCRIPTIONS,EXAMPLES,PROBLEM_DIFFICULTY,CATEGORY,TAG,Similar Questions ID,Accepted,Submissions,Acceptance Rate,Discussion Count,B75,NC.io,B50,G75,LC,SP
1,LRU Cache,https://leetcode.com/problems/lru-cache/,"Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.

Implement the LRUCache class:
* LRUCache(int capacity) Initialize the LRU cache with positive size capacity.
* int get(int key) Return the value of the key if the key exists, otherwise return -1.
* void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.

The functions get and put must each run in O(1) average time complexity.","Example 1:

Input
[""LRUCache"", ""put"", ""put"", ""get"", ""put"", ""get"", ""put"", ""get"", ""get"", ""get""]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, null, -1, 3, 4]

Explanation
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4",Medium,Linked List,"Design/OOD, Hash Table, Linked List, Doubly-Linked List",383,1.6M,3.8M,42.50%,190,,X,,X,X,
2,Min Stack,https://leetcode.com/problems/min-stack/,"Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

Implement the MinStack class:
* MinStack() initializes the stack object.
* void push(int val) pushes the element val onto the stack.
* void pop() removes the element on the top of the stack.
* int top() gets the top element of the stack.
* int getMin() retrieves the minimum element in the stack.

You must implement a solution with O(1) time complexity for each function.","Example 1:

Input
[""MinStack"",""push"",""push"",""push"",""getMin"",""pop"",""top"",""getMin""]
[[],[-2],[0],[-3],[],[],[],[]]

Output
[null,null,null,null,-3,null,0,-2]

Explanation
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // return -3
minStack.pop();
minStack.top();    // return 0
minStack.getMin(); // return -2",Easy,Stack,"Design/OOD, Stack",68,1.7M,3.1M,54.20%,105,,X,,X,X,
3,Implement Queue Using Stacks,https://leetcode.com/problems/implement-queue-using-stacks/,"Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).

Implement the MyQueue class:
* void push(int x) Pushes element x to the back of the queue.
* int pop() Removes the element from the front of the queue and returns it.
* int peek() Returns the element at the front of the queue.
* boolean empty() Returns true if the queue is empty, false otherwise.

Notes:
You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.
Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.

Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer.

","Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).

Implement the MyQueue class:

void push(int x) Pushes element x to the back of the queue.
int pop() Removes the element from the front of the queue and returns it.
int peek() Returns the element at the front of the queue.
boolean empty() Returns true if the queue is empty, false otherwise.
Notes:

You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.
Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.",Easy,Stack,"Design/OOD, Stack, Queue",4,928.6K,1.4M,66.30%,93,,,,X,,
4,Implement Stack Using Queues,https://leetcode.com/problems/implement-stack-using-queues/,"Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).

Implement the MyStack class:
* void push(int x) Pushes element x to the top of the stack.
* int pop() Removes the element on the top of the stack and returns it.
* int top() Returns the element on the top of the stack.
* boolean empty() Returns true if the stack is empty, false otherwise.

Notes:
You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid.
Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.","Example 1:

Input
[""MyStack"", ""push"", ""push"", ""top"", ""pop"", ""empty""]
[[], [1], [2], [], [], []]
Output
[null, null, null, 2, 2, false]

Explanation
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // return 2
myStack.pop(); // return 2
myStack.empty(); // return False
 

Constraints:

1 <= x <= 9
At most 100 calls will be made to push, pop, top, and empty.
All the calls to pop and top are valid.",Easy,Stack,"Design/OOD, Stack, Queue",3,668.7K,1M,63.80%,54,,,,,,
5,Insert Delete GetRandom O(1),https://leetcode.com/problems/insert-delete-getrandom-o1/,"Implement the RandomizedSet class:

RandomizedSet() Initializes the RandomizedSet object.
bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.
You must implement the functions of the class such that each function works in average O(1) time complexity.","Example 1:

Input
[""RandomizedSet"", ""insert"", ""remove"", ""insert"", ""getRandom"", ""remove"", ""insert"", ""getRandom""]
[[], [1], [2], [2], [], [1], [2], []]
Output
[null, true, false, true, 2, true, false, 2]

Explanation
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomizedSet.remove(2); // Returns false as 2 does not exist in the set.
randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].
randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.
randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].
randomizedSet.insert(2); // 2 was already in the set, so return false.
randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.
 

Constraints:

-231 <= val <= 231 - 1
At most 2 * 105 calls will be made to insert, remove, and getRandom.
There will be at least one element in the data structure when getRandom is called.",Medium,,Design/OOD,,908.4K,1.7M,54.40%,143,,,,X,X,
6,Insert Delete GetRandom O(1) Duplicates,https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/,"RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also reporting a random element.

Implement the RandomizedCollection class:

RandomizedCollection() Initializes the empty RandomizedCollection object.
bool insert(int val) Inserts an item val into the multiset, even if the item is already present. Returns true if the item is not present, false otherwise.
bool remove(int val) Removes an item val from the multiset if present. Returns true if the item is present, false otherwise. Note that if val has multiple occurrences in the multiset, we only remove one of them.
int getRandom() Returns a random element from the current multiset of elements. The probability of each element being returned is linearly related to the number of the same values the multiset contains.
You must implement the functions of the class such that each function works on average O(1) time complexity.

Note: The test cases are generated such that getRandom will only be called if there is at least one item in the RandomizedCollection.","Example 1:

Input
[""RandomizedCollection"", ""insert"", ""insert"", ""insert"", ""getRandom"", ""remove"", ""getRandom""]
[[], [1], [1], [2], [], [1], []]
Output
[null, true, false, true, 2, true, 1]

Explanation
RandomizedCollection randomizedCollection = new RandomizedCollection();
randomizedCollection.insert(1);   // return true since the collection does not contain 1.
                                  // Inserts 1 into the collection.
randomizedCollection.insert(1);   // return false since the collection contains 1.
                                  // Inserts another 1 into the collection. Collection now contains [1,1].
randomizedCollection.insert(2);   // return true since the collection does not contain 2.
                                  // Inserts 2 into the collection. Collection now contains [1,1,2].
randomizedCollection.getRandom(); // getRandom should:
                                  // - return 1 with probability 2/3, or
                                  // - return 2 with probability 1/3.
randomizedCollection.remove(1);   // return true since the collection contains 1.
                                  // Removes 1 from the collection. Collection now contains [1,2].
randomizedCollection.getRandom(); // getRandom should return 1 or 2, both equally likely.
 

Constraints:

-231 <= val <= 231 - 1
At most 2 * 105 calls in total will be made to insert, remove, and getRandom.
There will be at least one element in the data structure when getRandom is called.",Hard,,Design/OOD,,142.4K,401.5K,35.50%,21,,,,,,
7,Shuffle an Array,https://leetcode.com/problems/shuffle-an-array/,"Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling.

Implement the Solution class:

Solution(int[] nums) Initializes the object with the integer array nums.
int[] reset() Resets the array to its original configuration and returns it.
int[] shuffle() Returns a random shuffling of the array.","Example 1:

Input
[""Solution"", ""shuffle"", ""reset"", ""shuffle""]
[[[1, 2, 3]], [], [], []]
Output
[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]

Explanation
Solution solution = new Solution([1, 2, 3]);
solution.shuffle();    // Shuffle the array [1,2,3] and return its result.
                       // Any permutation of [1,2,3] must be equally likely to be returned.
                       // Example: return [3, 1, 2]
solution.reset();      // Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]
solution.shuffle();    // Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2]

 

Constraints:

1 <= nums.length <= 50
-106 <= nums[i] <= 106
All the elements of nums are unique.
At most 104 calls in total will be made to reset and shuffle.",Medium,,Design/OOD,,335.3K,574.9K,58.30%,21,,,,,X,
8,Random Pick with Weight,https://leetcode.com/problems/random-pick-with-weight/,"You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index.

You need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] / sum(w).

For example, if w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.25 (i.e., 25%), and the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e., 75%).","Example 1:

Input
[""Solution"",""pickIndex""]
[[[1]],[]]
Output
[null,0]

Explanation
Solution solution = new Solution([1]);
solution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.
Example 2:

Input
[""Solution"",""pickIndex"",""pickIndex"",""pickIndex"",""pickIndex"",""pickIndex""]
[[[1,3]],[],[],[],[],[]]
Output
[null,1,1,1,1,0]

Explanation
Solution solution = new Solution([1, 3]);
solution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.
solution.pickIndex(); // return 1
solution.pickIndex(); // return 1
solution.pickIndex(); // return 1
solution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.

Since this is a randomization problem, multiple answers are allowed.
All of the following outputs can be considered correct:
[null,1,1,1,1,0]
[null,1,1,1,1,1]
[null,1,1,1,0,0]
[null,1,1,1,0,1]
[null,1,0,1,0,0]
......
and so on.
 

Constraints:

1 <= w.length <= 104
1 <= w[i] <= 105
pickIndex will be called at most 104 times.",Medium,,Design/OOD,,454.8K,970.8K,46.80%,62,,,,X,,
9,Time-Based Key Value Store,https://leetcode.com/problems/time-based-key-value-store/,"Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.

Implement the TimeMap class:

TimeMap() Initializes the object of the data structure.
void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp.
String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If there are no values, it returns """".
","Example 1:

Input
[""TimeMap"", ""set"", ""get"", ""get"", ""set"", ""get"", ""get""]
[[], [""foo"", ""bar"", 1], [""foo"", 1], [""foo"", 3], [""foo"", ""bar2"", 4], [""foo"", 4], [""foo"", 5]]
Output
[null, null, ""bar"", ""bar"", null, ""bar2"", ""bar2""]

Explanation
TimeMap timeMap = new TimeMap();
timeMap.set(""foo"", ""bar"", 1);  // store the key ""foo"" and value ""bar"" along with timestamp = 1.
timeMap.get(""foo"", 1);         // return ""bar""
timeMap.get(""foo"", 3);         // return ""bar"", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is ""bar"".
timeMap.set(""foo"", ""bar2"", 4); // store the key ""foo"" and value ""bar2"" along with timestamp = 4.
timeMap.get(""foo"", 4);         // return ""bar2""
timeMap.get(""foo"", 5);         // return ""bar2""
 

Constraints:

1 <= key.length, value.length <= 100
key and value consist of lowercase English letters and digits.
1 <= timestamp <= 107
All the timestamps timestamp of set are strictly increasing.
At most 2 * 105 calls will be made to set and get.",Medium,,Design/OOD,,437.6K,886K,49.40%,62,,X,,X,,
10,Logger Rate Limiter,https://leetcode.com/problems/logger-rate-limiter/,,,Easy,,Design/OOD,,,,,,,,,,,
11,Design Hit Counter,https://leetcode.com/problems/design-hit-counter/,,,Medium,,Design/OOD,,,,,,,,,X,,
12,Design Twitter,https://leetcode.com/problems/design-twitter/,"Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.

Implement the Twitter class:

Twitter() Initializes your twitter object.
void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.
List<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.
void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.
void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.","Example 1:

Input
[""Twitter"", ""postTweet"", ""getNewsFeed"", ""follow"", ""postTweet"", ""getNewsFeed"", ""unfollow"", ""getNewsFeed""]
[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]
Output
[null, null, [5], null, null, [6, 5], null, [5]]

Explanation
Twitter twitter = new Twitter();
twitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).
twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]
twitter.follow(1, 2);    // User 1 follows user 2.
twitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).
twitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.
twitter.unfollow(1, 2);  // User 1 unfollows user 2.
twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.
 

Constraints:

1 <= userId, followerId, followeeId <= 500
0 <= tweetId <= 104
All the tweets have unique IDs.
At most 3 * 104 calls will be made to postTweet, getNewsFeed, follow, and unfollow.",Medium,,"Design/OOD, Hash Table, Linked List, Heap",,177.8K,449.6K,39.50%,56,,X,,,,
13,Maximum Frequency Stack,https://leetcode.com/problems/maximum-frequency-stack/,"Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.

Implement the FreqStack class:

FreqStack() constructs an empty frequency stack.
void push(int val) pushes an integer val onto the top of the stack.
int pop() removes and returns the most frequent element in the stack.
If there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.
","Example 1:

Input
[""FreqStack"", ""push"", ""push"", ""push"", ""push"", ""push"", ""push"", ""pop"", ""pop"", ""pop"", ""pop""]
[[], [5], [7], [5], [7], [4], [5], [], [], [], []]
Output
[null, null, null, null, null, null, null, 5, 7, 5, 4]

Explanation
FreqStack freqStack = new FreqStack();
freqStack.push(5); // The stack is [5]
freqStack.push(7); // The stack is [5,7]
freqStack.push(5); // The stack is [5,7,5]
freqStack.push(7); // The stack is [5,7,5,7]
freqStack.push(4); // The stack is [5,7,5,7,4]
freqStack.push(5); // The stack is [5,7,5,7,4,5]
freqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].
freqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].
freqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].
freqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].
 

Constraints:

0 <= val <= 109
At most 2 * 104 calls will be made to push and pop.
It is guaranteed that there will be at least one element in the stack before calling pop.",Hard,,"Design/OOD, Hash Table, Stack, Ordered Set",,173.1K,260.9K,66.40%,15,,,,X,,X
14,Prefix and Suffix Search,https://leetcode.com/problems/prefix-and-suffix-search/,"Design a special dictionary that searches the words in it by a prefix and a suffix.

Implement the WordFilter class:

WordFilter(string[] words) Initializes the object with the words in the dictionary.
f(string pref, string suff) Returns the index of the word in the dictionary, which has the prefix pref and the suffix suff. If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return -1.","Example 1:

Input
[""WordFilter"", ""f""]
[[[""apple""]], [""a"", ""e""]]
Output
[null, 0]
Explanation
WordFilter wordFilter = new WordFilter([""apple""]);
wordFilter.f(""a"", ""e""); // return 0, because the word at index 0 has prefix = ""a"" and suffix = ""e"".
 

Constraints:

1 <= words.length <= 104
1 <= words[i].length <= 7
1 <= pref.length, suff.length <= 7
words[i], pref and suff consist of lowercase English letters only.
At most 104 calls will be made to the function f.",Hard,,"Design/OOD, Array, Hash Table, Trie",,96.5K,234.5K,41.20%,8,,,,,,X
15,Design Search Autocomplete System,https://leetcode.com/problems/design-search-autocomplete-system/,,,Hard,,Design/OOD,,,,,,,,,,,X
16,Design In-Memory File System,https://leetcode.com/problems/design-in-memory-file-system/,,,Hard,,Design/OOD,,,,,,,,,X,,
17,Operations on Tree,https://leetcode.com/problems/operations-on-tree/,"You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of the ith node. The root of the tree is node 0, so parent[0] = -1 since it has no parent. You want to design a data structure that allows users to lock, unlock, and upgrade nodes in the tree.

The data structure should support the following functions:

Lock: Locks the given node for the given user and prevents other users from locking the same node. You may only lock a node using this function if the node is unlocked.
Unlock: Unlocks the given node for the given user. You may only unlock a node using this function if it is currently locked by the same user.
Upgrade: Locks the given node for the given user and unlocks all of its descendants regardless of who locked it. You may only upgrade a node if all 3 conditions are true:
The node is unlocked,
It has at least one locked descendant (by any user), and
It does not have any locked ancestors.
Implement the LockingTree class:

LockingTree(int[] parent) initializes the data structure with the parent array.
lock(int num, int user) returns true if it is possible for the user with id user to lock the node num, or false otherwise. If it is possible, the node num will become locked by the user with id user.
unlock(int num, int user) returns true if it is possible for the user with id user to unlock the node num, or false otherwise. If it is possible, the node num will become unlocked.
upgrade(int num, int user) returns true if it is possible for the user with id user to upgrade the node num, or false otherwise. If it is possible, the node num will be upgraded.","Example 1:


Input
[""LockingTree"", ""lock"", ""unlock"", ""unlock"", ""lock"", ""upgrade"", ""lock""]
[[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]
Output
[null, true, false, true, true, true, false]

Explanation
LockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);
lockingTree.lock(2, 2);    // return true because node 2 is unlocked.
                           // Node 2 will now be locked by user 2.
lockingTree.unlock(2, 3);  // return false because user 3 cannot unlock a node locked by user 2.
lockingTree.unlock(2, 2);  // return true because node 2 was previously locked by user 2.
                           // Node 2 will now be unlocked.
lockingTree.lock(4, 5);    // return true because node 4 is unlocked.
                           // Node 4 will now be locked by user 5.
lockingTree.upgrade(0, 1); // return true because node 0 is unlocked and has at least one locked descendant (node 4).
                           // Node 0 will now be locked by user 1 and node 4 will now be unlocked.
lockingTree.lock(0, 1);    // return false because node 0 is already locked.
 

Constraints:

n == parent.length
2 <= n <= 2000
0 <= parent[i] <= n - 1 for i != 0
parent[0] == -1
0 <= num <= n - 1
1 <= user <= 104
parent represents a valid tree.
At most 2000 calls in total will be made to lock, unlock, and upgrade.",Medium,,Design/OOD,,15.6K,34K,45.70%,7,,,,,,
18,Rank Teams by Votes,https://leetcode.com/problems/rank-teams-by-votes/,"In a special ranking system, each voter gives a rank from highest to lowest to all teams participating in the competition.

The ordering of teams is decided by who received the most position-one votes. If two or more teams tie in the first position, we consider the second position to resolve the conflict, if they tie again, we continue this process until the ties are resolved. If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter.

You are given an array of strings votes which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above.

Return a string of all teams sorted by the ranking system.

","Example 1:

Input: votes = [""ABC"",""ACB"",""ABC"",""ACB"",""ACB""]
Output: ""ACB""
Explanation: 
Team A was ranked first place by 5 voters. No other team was voted as first place, so team A is the first team.
Team B was ranked second by 2 voters and ranked third by 3 voters.
Team C was ranked second by 3 voters and ranked third by 2 voters.
As most of the voters ranked C second, team C is the second team, and team B is the third.
Example 2:

Input: votes = [""WXYZ"",""XYZW""]
Output: ""XWYZ""
Explanation:
X is the winner due to the tie-breaking rule. X has the same votes as W for the first position, but X has one vote in the second position, while W does not have any votes in the second position. 
Example 3:

Input: votes = [""ZMNAGUEDSJYLBOPHRQICWFXTVK""]
Output: ""ZMNAGUEDSJYLBOPHRQICWFXTVK""
Explanation: Only one voter, so their votes are used for the ranking.
 

Constraints:

1 <= votes.length <= 1000
1 <= votes[i].length <= 26
votes[i].length == votes[j].length for 0 <= i, j < votes.length.
votes[i][j] is an English uppercase letter.
All characters of votes[i] are unique.
All the characters that occur in votes[0] also occur in votes[j] where 1 <= j < votes.length.",Medium,,Design/OOD,,72K,123.5K,58.30%,13,,,,,,
19,Design Underground System,https://leetcode.com/problems/design-underground-system/,"An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another.

Implement the UndergroundSystem class:

void checkIn(int id, string stationName, int t)
A customer with a card ID equal to id, checks in at the station stationName at time t.
A customer can only be checked into one place at a time.
void checkOut(int id, string stationName, int t)
A customer with a card ID equal to id, checks out from the station stationName at time t.
double getAverageTime(string startStation, string endStation)
Returns the average time it takes to travel from startStation to endStation.
The average time is computed from all the previous traveling times from startStation to endStation that happened directly, meaning a check in at startStation followed by a check out from endStation.
The time it takes to travel from startStation to endStation may be different from the time it takes to travel from endStation to startStation.
There will be at least one customer that has traveled from startStation to endStation before getAverageTime is called.
You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 < t2. All events happen in chronological order.",,Medium,,Design/OOD,,,,,,,,,,,
20,Design Excel Sum Formula,https://leetcode.com/problems/design-excel-sum-formula/description/,,,,,Design/OOD,,,,,,,,,,,
21,Online Stock Span,https://leetcode.com/problems/online-stock-span/,"Design an algorithm that collects daily price quotes for some stock and returns the span of that stock's price for the current day.

The span of the stock's price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.

For example, if the prices of the stock in the last four days is [7,2,1,2] and the price of the stock today is 2, then the span of today is 4 because starting from today, the price of the stock was less than or equal 2 for 4 consecutive days.
Also, if the prices of the stock in the last four days is [7,34,1,2] and the price of the stock today is 8, then the span of today is 3 because starting from today, the price of the stock was less than or equal 8 for 3 consecutive days.
Implement the StockSpanner class:

StockSpanner() Initializes the object of the class.
int next(int price) Returns the span of the stock's price given that today's price is price.","Example 1:

Input
[""UndergroundSystem"",""checkIn"",""checkIn"",""checkIn"",""checkOut"",""checkOut"",""checkOut"",""getAverageTime"",""getAverageTime"",""checkIn"",""getAverageTime"",""checkOut"",""getAverageTime""]
[[],[45,""Leyton"",3],[32,""Paradise"",8],[27,""Leyton"",10],[45,""Waterloo"",15],[27,""Waterloo"",20],[32,""Cambridge"",22],[""Paradise"",""Cambridge""],[""Leyton"",""Waterloo""],[10,""Leyton"",24],[""Leyton"",""Waterloo""],[10,""Waterloo"",38],[""Leyton"",""Waterloo""]]

Output
[null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000]

Explanation
UndergroundSystem undergroundSystem = new UndergroundSystem();
undergroundSystem.checkIn(45, ""Leyton"", 3);
undergroundSystem.checkIn(32, ""Paradise"", 8);
undergroundSystem.checkIn(27, ""Leyton"", 10);
undergroundSystem.checkOut(45, ""Waterloo"", 15);  // Customer 45 ""Leyton"" -> ""Waterloo"" in 15-3 = 12
undergroundSystem.checkOut(27, ""Waterloo"", 20);  // Customer 27 ""Leyton"" -> ""Waterloo"" in 20-10 = 10
undergroundSystem.checkOut(32, ""Cambridge"", 22); // Customer 32 ""Paradise"" -> ""Cambridge"" in 22-8 = 14
undergroundSystem.getAverageTime(""Paradise"", ""Cambridge""); // return 14.00000. One trip ""Paradise"" -> ""Cambridge"", (14) / 1 = 14
undergroundSystem.getAverageTime(""Leyton"", ""Waterloo"");    // return 11.00000. Two trips ""Leyton"" -> ""Waterloo"", (10 + 12) / 2 = 11
undergroundSystem.checkIn(10, ""Leyton"", 24);
undergroundSystem.getAverageTime(""Leyton"", ""Waterloo"");    // return 11.00000
undergroundSystem.checkOut(10, ""Waterloo"", 38);  // Customer 10 ""Leyton"" -> ""Waterloo"" in 38-24 = 14
undergroundSystem.getAverageTime(""Leyton"", ""Waterloo"");    // return 12.00000. Three trips ""Leyton"" -> ""Waterloo"", (10 + 12 + 14) / 3 = 12
Example 2:

Input
[""UndergroundSystem"",""checkIn"",""checkOut"",""getAverageTime"",""checkIn"",""checkOut"",""getAverageTime"",""checkIn"",""checkOut"",""getAverageTime""]
[[],[10,""Leyton"",3],[10,""Paradise"",8],[""Leyton"",""Paradise""],[5,""Leyton"",10],[5,""Paradise"",16],[""Leyton"",""Paradise""],[2,""Leyton"",21],[2,""Paradise"",30],[""Leyton"",""Paradise""]]

Output
[null,null,null,5.00000,null,null,5.50000,null,null,6.66667]

Explanation
UndergroundSystem undergroundSystem = new UndergroundSystem();
undergroundSystem.checkIn(10, ""Leyton"", 3);
undergroundSystem.checkOut(10, ""Paradise"", 8); // Customer 10 ""Leyton"" -> ""Paradise"" in 8-3 = 5
undergroundSystem.getAverageTime(""Leyton"", ""Paradise""); // return 5.00000, (5) / 1 = 5
undergroundSystem.checkIn(5, ""Leyton"", 10);
undergroundSystem.checkOut(5, ""Paradise"", 16); // Customer 5 ""Leyton"" -> ""Paradise"" in 16-10 = 6
undergroundSystem.getAverageTime(""Leyton"", ""Paradise""); // return 5.50000, (5 + 6) / 2 = 5.5
undergroundSystem.checkIn(2, ""Leyton"", 21);
undergroundSystem.checkOut(2, ""Paradise"", 30); // Customer 2 ""Leyton"" -> ""Paradise"" in 30-21 = 9
undergroundSystem.getAverageTime(""Leyton"", ""Paradise""); // return 6.66667, (5 + 6 + 9) / 3 = 6.66667
 

Constraints:

1 <= id, t <= 106
1 <= stationName.length, startStation.length, endStation.length <= 10
All strings consist of uppercase and lowercase English letters and digits.
There will be at most 2 * 104 calls in total to checkIn, checkOut, and getAverageTime.
Answers within 10-5 of the actual value will be accepted.",Medium,,Design/OOD,,230.7K,308.9K,74.70%,58,,,,,,
22,Design Circular Queue,https://leetcode.com/problems/design-circular-queue/,"Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle, and the last position is connected back to the first position to make a circle. It is also called ""Ring Buffer"".

One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.

Implement the MyCircularQueue class:

MyCircularQueue(k) Initializes the object with the size of the queue to be k.
int Front() Gets the front item from the queue. If the queue is empty, return -1.
int Rear() Gets the last item from the queue. If the queue is empty, return -1.
boolean enQueue(int value) Inserts an element into the circular queue. Return true if the operation is successful.
boolean deQueue() Deletes an element from the circular queue. Return true if the operation is successful.
boolean isEmpty() Checks whether the circular queue is empty or not.
boolean isFull() Checks whether the circular queue is full or not.
You must solve the problem without using the built-in queue data structure in your programming language. ","Example 1:

Input
[""MyCircularQueue"", ""enQueue"", ""enQueue"", ""enQueue"", ""enQueue"", ""Rear"", ""isFull"", ""deQueue"", ""enQueue"", ""Rear""]
[[3], [1], [2], [3], [4], [], [], [], [4], []]
Output
[null, true, true, true, false, 3, true, true, true, 4]

Explanation
MyCircularQueue myCircularQueue = new MyCircularQueue(3);
myCircularQueue.enQueue(1); // return True
myCircularQueue.enQueue(2); // return True
myCircularQueue.enQueue(3); // return True
myCircularQueue.enQueue(4); // return False
myCircularQueue.Rear();     // return 3
myCircularQueue.isFull();   // return True
myCircularQueue.deQueue();  // return True
myCircularQueue.enQueue(4); // return True
myCircularQueue.Rear();     // return 4
 

Constraints:

1 <= k <= 1000
0 <= value <= 1000
At most 3000 calls will be made to enQueue, deQueue, Front, Rear, isEmpty, and isFull.",Medium,,Design/OOD,,315K,612.3K,51.40%,24,,,,,,
23,Serialize/Deserialize Nested JSON ,https://leetcode.com/discuss/interview-question/124708/Print-JSON-format-String,"This was a recent interview question. Suppose we have given following string:

""{""id"": ""0001"", ""type"": ""donut"",""name"": ""Cake"",""ppu"": 0.55, ""batters"":{""batter"":[{ ""id"": ""1001"", ""type"": ""Regular"" },{ ""id"": ""1002"", ""type"": ""Chocolate"" }]},""topping"":[{ ""id"": ""5001"", ""type"": ""None"" },{ ""id"": ""5002"", ""type"": ""Glazed"" }]}""
we need to print it in following order:

{
        ""id"": ""0001"",
        ""type"": ""donut"",
        ""name"": ""Cake"",
        ""ppu"": 0.55,
        ""batters"":
                {
                        ""batter"":
                                [
                                        { ""id"": ""1001"", ""type"": ""Regular"" },
                                        { ""id"": ""1002"", ""type"": ""Chocolate"" }
                                ]
                },
        ""topping"":
                [
                        { ""id"": ""5001"", ""type"": ""None"" },
                        { ""id"": ""5002"", ""type"": ""Glazed"" }
                ]
}
",No example,Hard,,Design/OOD,,0,0,0%,27,,,,,,
,,,,,,,,,,,,,,,,,,
25,Two Sum,https://leetcode.com/problems/two-sum/,"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?


","Example 1:

Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
Example 2:

Input: nums = [3,2,4], target = 6
Output: [1,2]
Example 3:

Input: nums = [3,3], target = 6
Output: [0,1]
 

Constraints:

2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
Only one valid answer exists.
",Easy,Arrays & Hashing,Array,,13.2M,25.1M,52.60%,835,X,X,X,X,X,X
26,Two Sum 2,https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/,"Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.

Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.

The tests are generated such that there is exactly one solution. You may not use the same element twice.

Your solution must use only constant extra space.","Example 1:

Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].
Example 2:

Input: numbers = [2,3,4], target = 6
Output: [1,3]
Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].
Example 3:

Input: numbers = [-1,0], target = -1
Output: [1,2]
Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].
 

Constraints:

2 <= numbers.length <= 3 * 104
-1000 <= numbers[i] <= 1000
numbers is sorted in non-decreasing order.
-1000 <= target <= 1000
The tests are generated such that there is exactly one solution.",Medium,Arrays & Hashing,Array,,2M,3.3M,61.40%,153,,X,,,,
27,Best Time to Buy and Sell Stock,https://leetcode.com/problems/best-time-to-buy-and-sell-stock/,"You are given an array prices where prices[i] is the price of a given stock on the ith day.

You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.","Example 1:

Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
Example 2:

Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0.
 ",Easy,Sliding Window,Array,,4.7M,8.7M,53.70%,329,X,X,X,X,X,X
28,Best Time to Buy and Sell Stock w/Cooldown,https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/,"You are given an array prices where prices[i] is the price of a given stock on the ith day.

Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:

After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).
Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).

","Example 1:

Input: prices = [1,2,3,0,2]
Output: 3
Explanation: transactions = [buy, sell, cooldown, buy, sell]
Example 2:

Input: prices = [1]
Output: 0",Medium,Sliding Window,Array,,507.9K,872.5K,58.20%,45,,X,,,X,X
29,Longest Consecutive Sequence,https://leetcode.com/problems/longest-consecutive-sequence/,"Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.

You must write an algorithm that runs in O(n) time.","Example 1:

Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
Example 2:

Input: nums = [0,3,7,2,5,8,4,6,0,1]
Output: 9",Medium,Arrays & Hashing,Array,,1.8M,3.7M,47.30%,173,X,X,X,X,,X
30,Contains Duplicate,https://leetcode.com/problems/contains-duplicate/,"Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.","Example 1:

Input: nums = [1,2,3,1]
Output: true
Example 2:

Input: nums = [1,2,3,4]
Output: false
Example 3:

Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: true",Easy,Arrays & Hashing,Array,,4M,6.5M,61.80%,260,X,X,X,X,,X
31,Product of Array Except Self,https://leetcode.com/problems/product-of-array-except-self/,"Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)","xample 1:

Input: nums = [1,2,3,4]
Output: [24,12,8,6]
Example 2:

Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]
 

Constraints:

2 <= nums.length <= 105
-30 <= nums[i] <= 30
The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.",Medium,Arrays & Hashing,Array,,2.6M,4M,66.30%,293,X,X,X,X,X,X
32,Maximum Subarray,https://leetcode.com/problems/maximum-subarray/,"Given an integer array nums, find the subarray with the largest sum, and return its sume

Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.

","Example 1:

Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: The subarray [4,-1,2,1] has the largest sum 6.
Example 2:

Input: nums = [1]
Output: 1
Explanation: The subarray [1] has the largest sum 1.
Example 3:

Input: nums = [5,4,-1,7,8]
Output: 23
Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.
",Easy,,Array,,3.9M,7.7M,50.80%,211,X,X,X,X,X,
33,Maximum Product Subarray,https://leetcode.com/problems/maximum-product-subarray/,"Given an integer array nums, find a subarray that has the largest product, and return the product","Example 1:

Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
Example 2:

Input: nums = [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
 

Constraints:

1 <= nums.length <= 2 * 104
-10 <= nums[i] <= 10
The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.",Medium,,Array,,1.3M,3.6M,35.10%,116,X,X,X,X,,X
34,Single Number,https://leetcode.com/problems/single-number/,"Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

You must implement a solution with a linear runtime complexity and use only constant extra space.","Example 1:

Input: nums = [2,2,1]
Output: 1
Example 2:

Input: nums = [4,1,2,1,2]
Output: 4
Example 3:

Input: nums = [1]
Output: 1
 

Constraints:

1 <= nums.length <= 3 * 104
-3 * 104 <= nums[i] <= 3 * 104
Each element in the array appears twice except for one element which appears only once.",Easy,Bit Manipulation,Array,,2.8M,3.8M,73.00%,133,,X,,X,X,X
35,Missing Number,https://leetcode.com/problems/missing-number/,"Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.

Follow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?

","Example 1:

Input: nums = [3,0,1]
Output: 2
Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.
Example 2:

Input: nums = [0,1]
Output: 2
Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.
Example 3:

Input: nums = [9,6,4,2,3,5,7,0,1]
Output: 8
Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.
 

Constraints:

n == nums.length
1 <= n <= 104
0 <= nums[i] <= n
All the numbers of nums are unique.",Easy,Bit Manipulation,Array,,2.2M,3.3M,66.90%,207,,X,,X,,X
36,Find all Numbers Disappeared in an Array,https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/,"Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.

Follow up: Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.



","Example 1:

Input: nums = [4,3,2,7,8,2,3,1]
Output: [5,6]
Example 2:

Input: nums = [1,1]
Output: [2]",Easy,,Array,,885.6K,1.5M,61.00%,50,,,,,,X
37,Find all Duplicates in Array,https://leetcode.com/problems/find-all-duplicates-in-an-array/,"Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice. You must write an algorithm that runs in O(n) time and uses only constant extra space.","Example 1:

Input: nums = [4,3,2,7,8,2,3,1]
Output: [2,3]
Example 2:

Input: nums = [1,1,2]
Output: [1]
Example 3:

Input: nums = [1]
Output: []",Medium,,Array,,,,,,,,,,,X
38,First Missing Positive,https://leetcode.com/problems/first-missing-positive/,"Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.

You must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.","Example 1:

Input: nums = [1,2,0]
Output: 3
Explanation: The numbers in the range [1,2] are all in the array.
Example 2:

Input: nums = [3,4,-1,1]
Output: 2
Explanation: 1 is in the array but 2 is missing.
Example 3:

Input: nums = [7,8,9,11,12]
Output: 1
Explanation: The smallest positive integer 1 is missing.",Hard,,Array,,,,,,,,,X,X,X
39,Rotate Array,https://leetcode.com/problems/rotate-array/,"Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.

","Example 1:

Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
Example 2:

Input: nums = [-1,-100,3,99], k = 2
Output: [3,99,-1,-100]
Explanation: 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]",Easy,,Array,,,,,,,,,X,X,
40,Contiguous Array,https://leetcode.com/problems/contiguous-array/,"Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.

","Example 1:

Input: nums = [0,1]
Output: 2
Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.
Example 2:

Input: nums = [0,1,0]
Output: 2
Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.",Medium,,Array,,,,,,,,,X,,
41,Missing Ranges,https://leetcode.com/problems/missing-ranges/,,,Easy,,Array,,,,,,,,,,X,
42,Majority Element,https://leetcode.com/problems/majority-element/,"Given an array nums of size n, return the majority element.

The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.","Example 1:

Input: nums = [3,2,3]
Output: 3
Example 2:

Input: nums = [2,2,1,1,1,2,2]
Output: 2",Easy,,Array,,,,,,,,,X,X,
43,Range Sum Query,https://leetcode.com/problems/range-sum-query-immutable/,"Given an integer array nums, handle multiple queries of the following type:

Calculate the sum of the elements of nums between indices left and right inclusive where left <= right.
Implement the NumArray class:

NumArray(int[] nums) Initializes the object with the integer array nums.
int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).
","Example 1:

Input
[""NumArray"", ""sumRange"", ""sumRange"", ""sumRange""]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
Output
[null, 1, -1, -3]

Explanation
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1
numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1
numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3",Easy,,Array,,,,,,,,,,,X
44,Subarray Sum Equals K,https://leetcode.com/problems/subarray-sum-equals-k/,"Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.

A subarray is a contiguous non-empty sequence of elements within an array.","Example 1:

Input: nums = [1,1,1], k = 2
Output: 2
Example 2:

Input: nums = [1,2,3], k = 3
Output: 2",Medium,,Array,,,,,,,,,X,,
45,Two City Scheduling,https://leetcode.com/problems/two-city-scheduling/solution/,,,Medium,,Array,,,,,,,,,,,
46,Maximum Profit in Job Scheduling,https://leetcode.com/problems/maximum-profit-in-job-scheduling/,"We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].

You're given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.

If you choose a job that ends at time X you will be able to start another job that starts at time X.","Example 1:
Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]
Output: 120
Explanation: The subset chosen is the first and fourth job. 
Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.

Example 2:
Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]
Output: 150
Explanation: The subset chosen is the first, fourth and fifth job. 
Profit obtained 150 = 20 + 70 + 60.

Example 3:
Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]
Output: 6",Hard,,Array,,,,,,,,,X,,
47,"Minimum Number of Arrows 
to Burst Balloons",https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/,"There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.

Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.

Given the array points, return the minimum number of arrows that must be shot to burst all balloons.","Example 1:

Input: points = [[10,16],[2,8],[1,6],[7,12]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].
- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].
Example 2:

Input: points = [[1,2],[3,4],[5,6],[7,8]]
Output: 4
Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows.
Example 3:

Input: points = [[1,2],[2,3],[3,4],[4,5]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].
- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].
",Medium,,Array,,,,,,,,,,,X
48,Gas Station,https://leetcode.com/problems/gas-station/,"There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].

You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.

Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique

","Example 1:

Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
Output: 3
Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.
Example 2:

Input: gas = [2,3,4], cost = [3,4,3]
Output: -1
Explanation:
You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 3 + 2 = 3
Travel to station 1. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can't travel around the circuit once no matter where you start.",Medium,,Array,,,,,,,X,,X,,
49,Hand of Straights,https://leetcode.com/problems/hand-of-straights/,"Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.

Given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.","Example 1:

Input: hand = [1,2,3,6,2,3,4,7,8], groupSize = 3
Output: true
Explanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]
Example 2:

Input: hand = [1,2,3,4,5], groupSize = 4
Output: false
Explanation: Alice's hand can not be rearranged into groups of 4.",Medium,,Array,,,,,,,X,,,,
50,Merge Triplets to Form Target Triplet,https://leetcode.com/problems/merge-triplets-to-form-target-triplet/,"A triplet is an array of three integers. You are given a 2D integer array triplets, where triplets[i] = [ai, bi, ci] describes the ith triplet. You are also given an integer array target = [x, y, z] that describes the triplet you want to obtain.

To obtain target, you may apply the following operation on triplets any number of times (possibly zero):

Choose two indices (0-indexed) i and j (i != j) and update triplets[j] to become [max(ai, aj), max(bi, bj), max(ci, cj)].
For example, if triplets[i] = [2, 5, 3] and triplets[j] = [1, 7, 5], triplets[j] will be updated to [max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5].
Return true if it is possible to obtain the target triplet [x, y, z] as an element of triplets, or false otherwise.","Example 1:

Input: triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]
Output: true
Explanation: Perform the following operations:
- Choose the first and last triplets [[2,5,3],[1,8,4],[1,7,5]]. Update the last triplet to be [max(2,1), max(5,7), max(3,5)] = [2,7,5]. triplets = [[2,5,3],[1,8,4],[2,7,5]]
The target triplet [2,7,5] is now an element of triplets.
Example 2:

Input: triplets = [[3,4,5],[4,5,6]], target = [3,2,5]
Output: false
Explanation: It is impossible to have [3,2,5] as an element because there is no 2 in any of the triplets.
Example 3:

Input: triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5]
Output: true
Explanation: Perform the following operations:
- Choose the first and third triplets [[2,5,3],[2,3,4],[1,2,5],[5,2,3]]. Update the third triplet to be [max(2,1), max(5,2), max(3,5)] = [2,5,5]. triplets = [[2,5,3],[2,3,4],[2,5,5],[5,2,3]].
- Choose the third and fourth triplets [[2,5,3],[2,3,4],[2,5,5],[5,2,3]]. Update the fourth triplet to be [max(2,5), max(5,2), max(5,3)] = [5,5,5]. triplets = [[2,5,3],[2,3,4],[2,5,5],[5,5,5]].
The target triplet [5,5,5] is now an element of triplets.",Medium,,Array,,,,,,,X,,,,
,,,,,,,,,,,,,,,,,,
52,3Sum,https://leetcode.com/problems/3sum/,"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

Notice that the solution set must not contain duplicate triplets.","Example 1:

Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
Example 2:

Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
Example 3:

Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.",Medium,Two Pointers,2 Pointers,,,,,,X,X,X,X,,X
53,3Sum Closest,https://leetcode.com/problems/3sum-closest/,"Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.

Return the sum of the three integers.

You may assume that each input would have exactly one solution.","Example 1:

Input: nums = [-1,2,1,-4], target = 1
Output: 2
Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
Example 2:

Input: nums = [0,0,0], target = 1
Output: 0
Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).",Medium,Two Pointers,2 Pointers,,,,,,,,,X,,X
54,Container With Most Water,https://leetcode.com/problems/container-with-most-water/,"You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return the maximum amount of water a container can store.

Notice that you may not slant the container.","Example 1:
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.

Example 2:
Input: height = [1,1]
Output: 1",Medium,Two Pointers,2 Pointers,,,,,,X,X,X,X,,X
55,Trapping Rain Water,https://leetcode.com/problems/trapping-rain-water/,"Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

","Example 1:


Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
Example 2:

Input: height = [4,2,0,3,2,5]
Output: 9
 

Constraints:

n == height.length
1 <= n <= 2 * 104
0 <= height[i] <= 105",Hard,Two Pointers,2 Pointers,,,,,,,X,,X,X,X
56,Intersection of Two Arrays 2,https://leetcode.com/problems/intersection-of-two-arrays-ii/,,,Easy,Two Pointers,2 Pointers,,,,,,,,,,X,
57,Sort Colors,https://leetcode.com/problems/sort-colors/,,,Medium,Two Pointers,2 Pointers,,,,,,,,,X,X,X
58,Squares of a Sorted Array,https://leetcode.com/problems/squares-of-a-sorted-array/,,,Easy,Two Pointers,2 Pointers,,,,,,,,,X,,X
59,Move Zeroes,https://leetcode.com/problems/move-zeroes/,,,Easy,Two Pointers,2 Pointers,,,,,,,,,X,,
60,Find the Duplicate Number,https://leetcode.com/problems/find-the-duplicate-number/,"Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.

There is only one repeated number in nums, return this repeated number.

You must solve the problem without modifying the array nums and uses only constant extra space.

Follow up:

How can we prove that at least one duplicate number must exist in nums?
Can you solve the problem in linear runtime complexity?","Example 1:

Input: nums = [1,3,4,2,2]
Output: 2
Example 2:

Input: nums = [3,1,3,4,2]
Output: 3
Example 3:

Input: nums = [3,3,3,3,3]
Output: 3
 

Constraints:

1 <= n <= 105
nums.length == n + 1
1 <= nums[i] <= n
All the integers in nums appear only once except for precisely one integer which appears two or more times.",Medium,,"2 Pointers, Binary Search, Bit Manipulatio",,1.7M,2.8M,60.80%,274,,X,,X,,X
61,Subarray Product Less Than K,https://leetcode.com/problems/subarray-product-less-than-k/,,,Medium,Two Pointers,2 Pointers,,,,,,,,,,,X
62,Next Permutation,https://leetcode.com/problems/next-permutation/,,,Medium,Two Pointers,2 Pointers,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,
64,Longest Substring w/out Repeating Chars,https://leetcode.com/problems/longest-substring-without-repeating-characters/,,,Medium,Sliding Window,Sliding Window,,,,,,X,X,X,X,X,X
65,Longest Repeating Character Replacement,https://leetcode.com/problems/longest-repeating-character-replacement/,"You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.

Return the length of the longest substring containing the same letter you can get after performing the above operations.

","Example 1:

Input: s = ""ABAB"", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.
Example 2:

Input: s = ""AABABBA"", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form ""AABBBBA"".
The substring ""BBBB"" has the longest repeating letters, which is 4.
There may exists other ways to achieve this answer too.
 

Constraints:

1 <= s.length <= 105
s consists of only uppercase English letters.
0 <= k <= s.length",Medium,Sliding Window,"Sliding Window, Hash Table",,730.9K,1.4M,53.90%,90,X,X,X,X,,X
66,Minimum Window Substring,https://leetcode.com/problems/minimum-window-substring/,,,Hard,Sliding Window,Sliding Window,,,,,,X,X,X,X,X,X
67,Longest Substring w/at most K Distinct Chars,https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/,,,Hard,Sliding Window,Sliding Window,,,,,,,,,,X,
68,Sliding Window Maximum,https://leetcode.com/problems/sliding-window-maximum/,,,Hard,Sliding Window,Sliding Window,,,,,,,X,,X,X,X
69,Minimum Size Subarray Sum,https://leetcode.com/problems/minimum-size-subarray-sum/,,,Medium,Sliding Window,Sliding Window,,,,,,,,,,,X
70,Fruit Into Baskets,https://leetcode.com/problems/fruit-into-baskets/,"You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces.

You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:

You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.
Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.
Once you reach a tree with fruit that cannot fit in your baskets, you must stop.
Given the integer array fruits, return the maximum number of fruits you can pick.","Example 1:

Input: fruits = [1,2,1]
Output: 3
Explanation: We can pick from all 3 trees.
Example 2:

Input: fruits = [0,1,2,2]
Output: 3
Explanation: We can pick from trees [1,2,2].
If we had started at the first tree, we would only pick from trees [0,1].
Example 3:

Input: fruits = [1,2,3,2,2]
Output: 4
Explanation: We can pick from trees [2,3,2,2].
If we had started at the first tree, we would only pick from trees [1,2].",Medium,Sliding Window,"Sliding Window, Hash Table",,403K,910.2K,44.30%,90,,,,,,X
71,Permutation in String,https://leetcode.com/problems/permutation-in-string/,,,Medium,Sliding Window,Sliding Window,,,,,,,X,,,,X
72,Minimum Number of K Consecutive Bit Flips,https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/,,,Hard,Sliding Window,Sliding Window,,,,,,,,,,,X
73,"Count Unique Characters of 
All Substrings of a Given String",https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/,,,Hard,Sliding Window,Sliding Window,,,,,,,,,,,X
74,Substring with Concatenation of All Words,https://leetcode.com/problems/substring-with-concatenation-of-all-words/,"You are given a string s and an array of strings words. All the strings of words are of the same length.

A concatenated string is a string that exactly contains all the strings of any permutation of words concatenated.

For example, if words = [""ab"",""cd"",""ef""], then ""abcdef"", ""abefcd"", ""cdabef"", ""cdefab"", ""efabcd"", and ""efcdab"" are all concatenated strings. ""acdbef"" is not a concatenated string because it is not the concatenation of any permutation of words.
Return an array of the starting indices of all the concatenated substrings in s. You can return the answer in any order.","Example 1:

Input: s = ""barfoothefoobarman"", words = [""foo"",""bar""]

Output: [0,9]

Explanation:

The substring starting at 0 is ""barfoo"". It is the concatenation of [""bar"",""foo""] which is a permutation of words.
The substring starting at 9 is ""foobar"". It is the concatenation of [""foo"",""bar""] which is a permutation of words.

Example 2:

Input: s = ""wordgoodgoodgoodbestword"", words = [""word"",""good"",""best"",""word""]

Output: []

Explanation:

There is no concatenated substring.

Example 3:

Input: s = ""barfoofoobarthefoobarman"", words = [""bar"",""foo"",""the""]

Output: [6,9,12]

Explanation:

The substring starting at 6 is ""foobarthe"". It is the concatenation of [""foo"",""bar"",""the""].
The substring starting at 9 is ""barthefoo"". It is the concatenation of [""bar"",""the"",""foo""].
The substring starting at 12 is ""thefoobar"". It is the concatenation of [""the"",""foo"",""bar""].

 

Constraints:

1 <= s.length <= 104
1 <= words.length <= 5000
1 <= words[i].length <= 30
s and words[i] consist of lowercase English letters.",Hard,Sliding Window,"Sliding Window, String, Hash Table",,449.8K,1.4M,32.70%,115,,,,,,X
75,Find all Anagrams in a String,https://leetcode.com/problems/find-all-anagrams-in-a-string/,,,Medium,Sliding Window,Sliding Window,,,,,,,,,X,,
76,Frequency of the Most Frequent Element,https://leetcode.com/problems/frequency-of-the-most-frequent-element/,,,Medium,Sliding Window,Sliding Window,,,,,,,,,,,
77,"Minimum Number of Flips to 
Make Binary Strings Alternating",https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/,,,Medium,Sliding Window,Sliding Window,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,
79,Valid Anagram,https://leetcode.com/problems/valid-anagram/,"Given two strings s and t, return true if t is an anagram of s, and false otherwise.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?

","Example 1:

Input: s = ""anagram"", t = ""nagaram""
Output: true
Example 2:

Input: s = ""rat"", t = ""car""
Output: false
 

Constraints:

1 <= s.length, t.length <= 5 * 104
s and t consist of lowercase English letters.",Easy,Arrays & Hashing,"String, Hash Table, Sorting",,3.5M,5.4M,64.60%,183,X,X,X,X,,
80,Group Anagrams,https://leetcode.com/problems/group-anagrams/,,,Medium,Arrays & Hashing,String,,,,,,X,X,X,X,X,
81,Valid Palindrome,https://leetcode.com/problems/valid-palindrome/,,,Easy,Two Pointers,String,,,,,,X,X,,X,,
82,Valid Palindrome 2,https://leetcode.com/problems/valid-palindrome-ii/,,,Easy,Two Pointers,String,,,,,,X,,,,,
83,Longest Palindromic Substring,https://leetcode.com/problems/longest-palindromic-substring/,"Given a string s, return the longest palindromic substring in s.","Example 1:

Input: s = ""babad""
Output: ""bab""
Explanation: ""aba"" is also a valid answer.
Example 2:

Input: s = ""cbbd""
Output: ""bb""
 

Constraints:

1 <= s.length <= 1000
s consist of only digits and English letters.",Medium,,"String, Two Pointers, DP",,3.1M,9M,33.90%,288,X,X,,X,X,
84,Palindromic Substrings,https://leetcode.com/problems/palindromic-substrings/,,,Medium,,String,,,,,,X,X,X,,,X
85,Encode and Decode Strings,https://leetcode.com/problems/encode-and-decode-strings/,,,Medium,Arrays & Hashing,String,,,,,,X,X,X,X,,
86,Ransom Note,https://leetcode.com/problems/ransom-note/,,,Easy,,String,,,,,,,,,X,,
87,Palindrome Number,https://leetcode.com/problems/palindrome-number/,"Given an integer x, return true if x is a palindrome, and false otherwise.

Follow up: Could you solve it without converting the integer to a string?

 ","Example 1:

Input: x = 121
Output: true
Explanation: 121 reads as 121 from left to right and from right to left.
Example 2:

Input: x = -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
Example 3:

Input: x = 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
",Easy,,String,,4.6M,8.2M,56.40%,366,,,,X,,
88,Longest Common Prefix,https://leetcode.com/problems/longest-common-prefix/,,,Easy,,String,,,,,,,,,X,,
89,Backspace String Compare,https://leetcode.com/problems/backspace-string-compare/,,,Easy,,String,,,,,,,,,X,,X
90,Find First Palindrome in Array,https://leetcode.com/problems/find-first-palindromic-string-in-the-array/,,,Easy,,String,,,,,,,,,,,
91,Longest Palindrome,https://leetcode.com/problems/longest-palindrome/,"Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.

Letters are case sensitive, for example, ""Aa"" is not considered a palindrome here.","Example 1:

Input: s = ""abccccdd""
Output: 7
Explanation: One longest palindrome that can be built is ""dccaccd"", whose length is 7.
Example 2:

Input: s = ""a""
Output: 1
Explanation: The longest palindrome that can be built is ""a"", whose length is 1.
 

Constraints:

1 <= s.length <= 2000
s consists of lowercase and/or uppercase English letters only.",Easy,,"String, Greedy, Hash Table",,634.3K,1.2M,53.90%,51,,,,X,,
92,Reverse String,https://leetcode.com/problems/reverse-string/,,,Easy,,String,,,,,,,,,,X,
93,First Unique Character in a String,https://leetcode.com/problems/first-unique-character-in-a-string/,,,Easy,,String,,,,,,,,,,X,
94,String to Integer (atoi),https://leetcode.com/problems/string-to-integer-atoi/,,,Medium,,String,,,,,,,,,X,X,
95,Implement strStr(),https://leetcode.com/problems/implement-strstr/,"Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.","Example 1:

Input: haystack = ""sadbutsad"", needle = ""sad""
Output: 0
Explanation: ""sad"" occurs at index 0 and 6.
The first occurrence is at index 0, so we return 0.
Example 2:

Input: haystack = ""leetcode"", needle = ""leeto""
Output: -1
Explanation: ""leeto"" did not occur in ""leetcode"", so we return -1.
 

Constraints:

1 <= haystack.length, needle.length <= 104
haystack and needle consist of only lowercase English characters.",Easy,,"String, Two Pointers, String Matching",,2.5M,5.8M,42.40%,212,,,,,X,
96,Largest Number,https://leetcode.com/problems/largest-number/,,,Medium,,String,,,,,,,,,X,,
97,Reorganize String,https://leetcode.com/problems/reorganize-string/,,,Medium,,String,,,,,,,,,,,X
98,Reorganize String K Distance Apart,https://leetcode.com/problems/rearrange-string-k-distance-apart/,,,Hard,,String,,,,,,,,,,,X
99,Regular Expression Matching,https://leetcode.com/problems/regular-expression-matching/,"Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:

'.' Matches any single character.​​​​
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).","Example 1:

Input: s = ""aa"", p = ""a""
Output: false
Explanation: ""a"" does not match the entire string ""aa"".
Example 2:

Input: s = ""aa"", p = ""a*""
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes ""aa"".
Example 3:

Input: s = ""ab"", p = "".*""
Output: true
Explanation: "".*"" means ""zero or more (*) of any character (.)"".
 

Constraints:

1 <= s.length <= 20
1 <= p.length <= 20
s contains only lowercase English letters.
p contains only lowercase English letters, '.', and '*'.
It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",Hard,,"String, DP",,958.8K,3.4M,28.20%,303,,X,,,X,
100,Wildcard Matching,https://leetcode.com/problems/wildcard-matching/,,,Hard,,String,,,,,,,,,,,
101,Index Pairs of a String,https://leetcode.com/problems/index-pairs-of-a-string/,,,Easy,,String,,,,,,,,,,,X
102,Longest Word in Dictionary,https://leetcode.com/problems/longest-word-in-dictionary/,,,Medium,,String,,,,,,,,,,,X
103,Palindrome Pairs,https://leetcode.com/problems/palindrome-pairs/,"You are given a 0-indexed array of unique strings words.

A palindrome pair is a pair of integers (i, j) such that:

0 <= i, j < words.length,
i != j, and
words[i] + words[j] (the concatenation of the two strings) is a 
palindrome
.
Return an array of all the palindrome pairs of words.

You must write an algorithm with O(sum of words[i].length) runtime complexity.","Example 1:

Input: words = [""abcd"",""dcba"",""lls"",""s"",""sssll""]
Output: [[0,1],[1,0],[3,2],[2,4]]
Explanation: The palindromes are [""abcddcba"",""dcbaabcd"",""slls"",""llssssll""]
Example 2:

Input: words = [""bat"",""tab"",""cat""]
Output: [[0,1],[1,0]]
Explanation: The palindromes are [""battab"",""tabbat""]
Example 3:

Input: words = [""a"",""""]
Output: [[0,1],[1,0]]
Explanation: The palindromes are [""a"",""a""]
 

Constraints:

1 <= words.length <= 5000
0 <= words[i].length <= 300
words[i] consists of lowercase English letters.",Hard,,"String, Trie",,205.7K,582.1K,35.30%,31,,,,X,,X
104,Text Justification,https://leetcode.com/problems/text-justification/,,,Hard,,String,,,,,,,,,,,
105,Parition Labels,https://leetcode.com/problems/partition-labels/,,,Medium,,String,,,,,,,X,,,,
106,Valid Parenthesis String,https://leetcode.com/problems/valid-parenthesis-string/,,,Medium,,String,,,,,,,X,,,,
107,Verifying an Alien Dictionary,https://leetcode.com/problems/verifying-an-alien-dictionary/,"In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.

Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language.

","Example 1:

Input: words = [""hello"",""leetcode""], order = ""hlabcdefgijkmnopqrstuvwxyz""
Output: true
Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted.
Example 2:

Input: words = [""word"",""world"",""row""], order = ""worldabcefghijkmnpqstuvxyz""
Output: false
Explanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.
Example 3:

Input: words = [""apple"",""app""], order = ""abcdefghijklmnopqrstuvwxyz""
Output: false
Explanation: The first three characters ""app"" match, and the second string is shorter (in size.) According to lexicographical rules ""apple"" > ""app"", because 'l' > '∅', where '∅' is defined as the blank character which is less than any other character (More info).
 

Constraints:

1 <= words.length <= 100
1 <= words[i].length <= 20
order.length == 26
All characters in words[i] and order are English lowercase letters.",Easy,,"String, Hash Table",,504K,916.5K,55.00%,120,,,,,,
,,,,,,,,,,,,,,,,,,
109,Valid Parentheses,https://leetcode.com/problems/valid-parentheses/,,,Easy,Stack,Stack,,,,,,X,X,X,X,X,
110,Longest Valid Parenthesis,https://leetcode.com/problems/longest-valid-parentheses/,,,Hard,Stack,Stack,,,,,,,,,X,,
111,Largest Rectangle in Histogram,https://leetcode.com/problems/largest-rectangle-in-histogram/,"Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.

","Example 1:


Input: heights = [2,1,5,6,2,3]
Output: 10
Explanation: The above is a histogram where width of each bar is 1.
The largest rectangle is shown in the red area, which has an area = 10 units.
Example 2:


Input: heights = [2,4]
Output: 4
",Hard,Stack,"Stack, Monotonic Stack",,890.5K,2M,44.50%,110,,X,,X,X,
112,Daily Temperatures,https://leetcode.com/problems/daily-temperatures/,,,Medium,Stack,Stack,,,,,,,X,,X,,
113,Asteroid Collision,https://leetcode.com/problems/asteroid-collision/,,,Medium,Stack,Stack,,,,,,,,,X,,
114,Car Fleet,https://leetcode.com/problems/car-fleet/,"There are n cars going to the same destination along a one-lane road. The destination is target miles away.

You are given two integer array position and speed, both of length n, where position[i] is the position of the ith car and speed[i] is the speed of the ith car (in miles per hour).

A car can never pass another car ahead of it, but it can catch up to it and drive bumper to bumper at the same speed. The faster car will slow down to match the slower car's speed. The distance between these two cars is ignored (i.e., they are assumed to have the same position).

A car fleet is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.

If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.

Return the number of car fleets that will arrive at the destination.","Example 1:

Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]
Output: 3
Explanation:
The cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12.
The car starting at 0 does not catch up to any other car, so it is a fleet by itself.
The cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.
Note that no other cars meet these fleets before the destination, so the answer is 3.
Example 2:

Input: target = 10, position = [3], speed = [3]
Output: 1
Explanation: There is only one car, hence there is only one fleet.
Example 3:

Input: target = 100, position = [0,2,4], speed = [4,2,1]
Output: 1
Explanation:
The cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The fleet moves at speed 2.
Then, the fleet (speed 2) and the car starting at 4 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.
 

Constraints:

n == position.length == speed.length
1 <= n <= 105
0 < target <= 106
0 <= position[i] < target
All the values of position are unique.
0 < speed[i] <= 106",Medium,Stack,"Stack, Monotonic Stack, Sorting",,253.1K,495.6K,51.10%,82,,X,,,,
115,"Basic Calculator (+, -, parentheses, space)",https://leetcode.com/problems/basic-calculator/,,,Hard,Stack,Stack,,,,,,,,,X,,
116,"Basic Calculator 2 (+, -, *, /)",https://leetcode.com/problems/basic-calculator-ii/,,,Medium,Stack,Stack,,,,,,,,,X,,
117,Evaluate Reverse Polish Notation,https://leetcode.com/problems/evaluate-reverse-polish-notation/,,,Medium,Stack,Stack,,,,,,,X,,X,,
118,Parse Lisp Expression,https://leetcode.com/problems/parse-lisp-expression/,"You are given a string expression representing a Lisp-like expression to return the integer value of.

The syntax for these expressions is given as follows.

An expression is either an integer, let expression, add expression, mult expression, or an assigned variable. Expressions always evaluate to a single integer.
(An integer could be positive or negative.)
A let expression takes the form ""(let v1 e1 v2 e2 ... vn en expr)"", where let is always the string ""let"", then there are one or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let expression is the value of the expression expr.
An add expression takes the form ""(add e1 e2)"" where add is always the string ""add"", there are always two expressions e1, e2 and the result is the addition of the evaluation of e1 and the evaluation of e2.
A mult expression takes the form ""(mult e1 e2)"" where mult is always the string ""mult"", there are always two expressions e1, e2 and the result is the multiplication of the evaluation of e1 and the evaluation of e2.
For this question, we will use a smaller subset of variable names. A variable starts with a lowercase letter, then zero or more lowercase letters or digits. Additionally, for your convenience, the names ""add"", ""let"", and ""mult"" are protected and will never be used as variable names.
Finally, there is the concept of scope. When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially. It is guaranteed that every expression is legal. Please see the examples for more details on the scope.","Example 1:

Input: expression = ""(let x 2 (mult x (let x 3 y 4 (add x y))))""
Output: 14
Explanation: In the expression (add x y), when checking for the value of the variable x,
we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.
Since x = 3 is found first, the value of x is 3.
Example 2:

Input: expression = ""(let x 3 x 2 x)""
Output: 2
Explanation: Assignment in let statements is processed sequentially.
Example 3:

Input: expression = ""(let x 1 y 2 x (add x y) (add x y))""
Output: 5
Explanation: The first (add x y) evaluates as 3, and is assigned to x.
The second (add x y) evaluates as 3+2 = 5.
 

Constraints:

1 <= expression.length <= 2000
There are no leading or trailing spaces in expression.
All tokens are separated by a single space in expression.
The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer.
The expression is guaranteed to be legal and evaluate to an integer.",Hard,,"Stack, Recursio",,22.1K,42.8K,51.80%,6,,,,,,
119,Remove All Adjacent Duplicates in String 2,https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/,,,Medium,Stack,Stack,,,,,,,,,,,
120,Simplify Path,https://leetcode.com/problems/simplify-path/,,,Medium,Stack,Stack,,,,,,,,,,,
121,Decode String,https://leetcode.com/problems/decode-string/,,,Medium,Stack,Stack,,,,,,,,,,,
122,Remove K Digits,https://leetcode.com/problems/remove-k-digits/,"Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.

","Example 1:

Input: num = ""1432219"", k = 3
Output: ""1219""
Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.
Example 2:

Input: num = ""10200"", k = 1
Output: ""200""
Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.
Example 3:

Input: num = ""10"", k = 2
Output: ""0""
Explanation: Remove all the digits from the number and it is left with nothing which is 0.
 

Constraints:

1 <= k <= num.length <= 105
num consists of only digits.
num does not have any leading zeros except for the zero itself.",Medium,,"Stack, Greedy, Monotonic Stack",,481.1K,1.4M,33.60%,192,,,,,,
,,,,,,,,,,,,,,,,,,
124,Custom Binary Search Implementation (bisect in Python),https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/discuss/702162/python-lets-implement-pythons-bisect-algorithm,,,,,,,,,,,,,,,,
125,Powerful Binary Search Template for Problem Solving,https://leetcode.com/discuss/general-discussion/786126/python-powerful-ultimate-binary-search-template-solved-many-problems,,,,,,,,,,,,,,,,
126,Binary Search for Beginners,https://leetcode.com/discuss/general-discussion/691825/Binary-Search-for-Beginners-Problems-or-Patterns-or-Sample-solutions,,,,,,,,,,,,,,,,
127,Binary Search,https://leetcode.com/problems/binary-search/,"Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

You must write an algorithm with O(log n) runtime complexity.","Example 1:

Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4
Example 2:

Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1
 

Constraints:

1 <= nums.length <= 104
-104 < nums[i], target < 104
All the integers in nums are unique.
nums is sorted in ascending order.",Easy,Binary Search,Binary Search,,2.4M,4.2M,57.50%,107,,X,,X,,X
128,Find Minimum in Rotated Sorted Array,https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/,,,Medium,Binary Search,Binary Search,,,,,,X,X,X,X,,X
129,Search in Rotated Sorted Array,https://leetcode.com/problems/search-in-rotated-sorted-array/,,,Medium,Binary Search,Binary Search,,,,,,X,X,X,X,X,X
130,Search in Rotated Sorted Array 2,https://leetcode.com/problems/search-in-rotated-sorted-array-ii/,,,Medium,Binary Search,Binary Search,,,,,,,,,,,X
131,First Bad Version,https://leetcode.com/problems/first-bad-version/,"You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.","Example 1:

Input: n = 5, bad = 4
Output: 4
Explanation:
call isBadVersion(3) -> false
call isBadVersion(5) -> true
call isBadVersion(4) -> true
Then 4 is the first bad version.
Example 2:

Input: n = 1, bad = 1
Output: 1
",Easy,Binary Search,Binary Search,,1.7M,3.8M,44.40%,148,,,,X,X,
132,Search for a Range,https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/,,,Medium,Binary Search,Binary Search,,,,,,,,,,X,
133,Median of Two Sorted Arrays,https://leetcode.com/problems/median-of-two-sorted-arrays/,,,Hard,Binary Search,Binary Search,,,,,,,X,,X,X,X
134,Find Smallest Letter Greater than Target,https://leetcode.com/problems/find-smallest-letter-greater-than-target/,,,Easy,Binary Search,Binary Search,,,,,,,,,,,X
135,Peak Index in a Mountain Array,https://leetcode.com/problems/peak-index-in-a-mountain-array/,,,Easy,Binary Search,Binary Search,,,,,,,,,,,X
136,Kth Smallest Element in a Sorted Matrix,https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/,"Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.

Note that it is the kth smallest element in the sorted order, not the kth distinct element.

You must find a solution with a memory complexity better than O(n2).

Follow up:

Could you solve the problem with a constant memory (i.e., O(1) memory complexity)?
Could you solve the problem in O(n) time complexity? The solution may be too advanced for an interview but you may find reading this paper fun.

","Example 1:

Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
Output: 13
Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13
Example 2:

Input: matrix = [[-5]], k = 1
Output: -5
 

Constraints:

n == matrix.length == matrix[i].length
1 <= n <= 300
-109 <= matrix[i][j] <= 109
All the rows and columns of matrix are guaranteed to be sorted in non-decreasing order.
1 <= k <= n2",Medium,Matrix,"Binary Search, Heap, Matrix",,614K,982.7K,62.50%,31,,,,,,X
137,Search a 2D Matrix,https://leetcode.com/problems/search-a-2d-matrix/,,,Medium,Matrix,Binary Search,,,,,,,X,,X,,X
138,Search a 2D Matrix 2,https://leetcode.com/problems/search-a-2d-matrix-ii/,,,Medium,Matrix,Binary Search,,,,,,,,,,X,X
139,Find K Closest Elements,https://leetcode.com/problems/find-k-closest-elements/,,,Medium,Binary Search,Binary Search,,,,,,,,,X,,X
140,Count of Range Sum,https://leetcode.com/problems/count-of-range-sum/,"Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.

Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.

","Example 1:

Input: nums = [-2,5,-1], lower = -2, upper = 2
Output: 3
Explanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.
Example 2:

Input: nums = [0], lower = 0, upper = 0
Output: 1
",Hard,Binary Search,"Binary Search, Divide and Conquer, Binary Indexed Tree, Segment Tree, Merge Sort, Ordered Set",,76.8K,213.8K,35.90%,14,,,,,,X
141,Find Peak Element,https://leetcode.com/problems/find-peak-element/,,,Medium,Binary Search,Binary Search,,,,,,,,,,,X
142,Koko Eating Bananas,https://leetcode.com/problems/koko-eating-bananas/,,,Medium,Binary Search,Binary Search,,,,,,,X,,,,
143,Search Insert Position,https://leetcode.com/problems/search-insert-position/,,,Easy,Binary Search,Binary Search,,,,,,,,,,,
144,"Find First and Last Position of 
Element in Sorted Array",https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/,"Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.

If target is not found in the array, return [-1, -1].

You must write an algorithm with O(log n) runtime complexity.

","Example 1:

Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
Example 2:

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
Example 3:

Input: nums = [], target = 0
Output: [-1,-1]",Medium,Binary Search,Binary Search,,2M,4.6M,44.30%,163,,,,,,
145,Valid Perfect Square,https://leetcode.com/problems/valid-perfect-square/,,,Easy,Binary Search,Binary Search,,,,,,,,,,,
146,Guess Number Higher or Lower,https://leetcode.com/problems/guess-number-higher-or-lower/,,,Easy,Binary Search,Binary Search,,,,,,,,,,,
147,Maximum Number of Removable Characters,https://leetcode.com/problems/maximum-number-of-removable-characters/,,,Medium,Binary Search,Binary Search,,,,,,,,,,,
148,Leftmost Column with at Least a One,https://leetcode.com/problems/leftmost-column-with-at-least-a-one/,,,Medium,Binary Search,Binary Search,,,,,,,,,,,
149,Capacity to Ship Packages Within D Days,https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/,"A conveyor belt has packages that must be shipped from one port to another within days days.

The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.

Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days.","Example 1:

Input: weights = [1,2,3,4,5,6,7,8,9,10], days = 5
Output: 15
Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:
1st day: 1, 2, 3, 4, 5
2nd day: 6, 7
3rd day: 8
4th day: 9
5th day: 10

Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.
Example 2:

Input: weights = [3,2,2,4,1,4], days = 3
Output: 6
Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:
1st day: 3, 2
2nd day: 2, 4
3rd day: 1, 4
Example 3:

Input: weights = [1,2,3,1,1], days = 4
Output: 3
Explanation:
1st day: 1
2nd day: 2
3rd day: 3
4th day: 1, 1
",Medium,Binary Search,Binary Search,,377.7K,543.6K,69.50%,124,,,,,,
150,Cutting Ribbons,https://leetcode.com/problems/cutting-ribbons/,,,Medium,Binary Search,Binary Search,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,
152,Convert 1D Array into 2D Array,https://leetcode.com/problems/convert-1d-array-into-2d-array/,,,Easy,Matrix,Matrix,,,,,,,,,,,X
153,Set Matrix Zeroes,https://leetcode.com/problems/set-matrix-zeroes/,,,Medium,Math,Matrix,,,,,,X,X,,X,,X
154,Spiral Matrix,https://leetcode.com/problems/spiral-matrix/,"Given an m x n matrix, return all elements of the matrix in spiral order.

","Example 1:


Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]
Example 2:


Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]",Medium,Math,Matrix,,1.4M,2.9M,49.60%,116,X,X,,X,X,X
155,Rotate Image,https://leetcode.com/problems/rotate-image/,,,Medium,Math,Matrix,,,,,,X,X,,X,,X
156,Valid Sudoku,https://leetcode.com/problems/valid-sudoku/,,,Medium,Arrays & Hashing,Matrix,,,,,,,X,,X,,
157,01 Matrix,https://leetcode.com/problems/01-matrix/,,,Medium,Matrix,Matrix,,,,,,,,,X,,
,,,,,,,,,,,,,,,,,,
159,Reverse a Linked List,https://leetcode.com/problems/reverse-linked-list/,"Given the head of a singly linked list, reverse the list, and return the reversed list.

Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?


","Example 1:


Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
Example 2:


Input: head = [1,2]
Output: [2,1]
Example 3:

Input: head = []
Output: []
",Easy,Linked List,Linked List,,4.1M,5.4M,76.60%,197,X,X,X,X,X,X
160,Reverse Linked List 2,https://leetcode.com/problems/reverse-linked-list-ii/,,,Medium,Linked List,Linked List,,,,,,,,,,,X
161,Linked List Cycle (detect if exists),https://leetcode.com/problems/linked-list-cycle/,,,Easy,Linked List,Linked List,,,,,,X,X,X,x,,X
162,Linked List Cycle 2 (find cycle entry point),https://leetcode.com/problems/linked-list-cycle-ii/,,,Medium,Linked List,Linked List,,,,,,X,,,,,X
163,Merge Two Sorted Lists,https://leetcode.com/problems/merge-two-sorted-lists/,,,Easy,Linked List,Linked List,,,,,,X,X,,X,X,X
164,Remove Nth Node from End of List,https://leetcode.com/problems/remove-nth-node-from-end-of-list/,"Given the head of a linked list, remove the nth node from the end of the list and return its head.

Follow up: Could you do this in one pass?

","Example 1:


Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
Example 2:

Input: head = [1], n = 1
Output: []
Example 3:

Input: head = [1,2], n = 1
Output: [1]
 

Constraints:

The number of nodes in the list is sz.
1 <= sz <= 30
0 <= Node.val <= 100
1 <= n <= sz
 ",Medium,,"Linked List, Two Pointers",,2.7M,6M,45.40%,175,X,X,X,X,,X
165,Reorder List,https://leetcode.com/problems/reorder-list/,,,Medium,Linked List,Linked List,,,,,,X,X,,X,,X
166,Palindrome Linked List,https://leetcode.com/problems/palindrome-linked-list/,,,Easy,Linked List,Linked List,,,,,,,,,X,X,X
167,Intersection of two Linked Lists,https://leetcode.com/problems/intersection-of-two-linked-lists/,,,Easy,Linked List,Linked List,,,,,,,,,,X,
168,Copy Linked List with Random Pointer,https://leetcode.com/problems/copy-list-with-random-pointer/,,,Medium,Linked List,Linked List,,,,,,,X,,,X,
169,Sort List,https://leetcode.com/problems/sort-list/,"Given the head of a linked list, return the list after sorting it in ascending order.

Follow up: Can you sort the linked list in O(n logn) time and O(1) memory (i.e. constant space)?

","Example 1:


Input: head = [4,2,1,3]
Output: [1,2,3,4]
Example 2:


Input: head = [-1,5,3,4,0]
Output: [-1,0,3,4,5]
Example 3:

Input: head = []
Output: []",Medium,Linked List,"Linked List, Two Pointers, Divide and Conquer, Sorting",,788.7K,1.4M,58.00%,71,,,,X,X,X
170,Middle of the Linked List,https://leetcode.com/problems/middle-of-the-linked-list/,,,Easy,Linked List,Linked List,,,,,,,,,X,,X
171,Remove Linked List Elements,https://leetcode.com/problems/remove-linked-list-elements/Z,,,Easy,Linked List,Linked List,,,,,,,,,,,X
172,Remove Duplicates from Sorted List,https://leetcode.com/problems/remove-duplicates-from-sorted-list/,,,Easy,Linked List,Linked List,,,,,,,,,,,X
173,Add Two Numbers,https://leetcode.com/problems/add-two-numbers/,"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.","Example 1:


Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
Example 2:

Input: l1 = [0], l2 = [0]
Output: [0]
Example 3:

Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
 

Constraints:

The number of nodes in each linked list is in the range [1, 100].
0 <= Node.val <= 9
It is guaranteed that the list represents a number that does not have leading zeros.",Medium,,"Linked List, Math, Recursion",,4.6M,10.6M,42.90%,566,,X,,X,X,X
174,Add Two Numbers 2,https://leetcode.com/problems/add-two-numbers-ii/,,,Medium,Linked List,Linked List,,,,,,,,,,,
175,Sort List,https://leetcode.com/problems/sort-list/,,,Medium,Linked List,Linked List,,,,,,,,,,,X
176,Rotate List,https://leetcode.com/problems/rotate-list/,,,Medium,Linked List,Linked List,,,,,,,,,X,,X
177,Swap Nodes in Pairs,https://leetcode.com/problems/swap-nodes-in-pairs/,,,Medium,Linked List,Linked List,,,,,,,,,X,,X
178,Odd Even Linked List,https://leetcode.com/problems/odd-even-linked-list/,,,Medium,Linked List,Linked List,,,,,,,,,X,,X
179,Reverse Nodes in K Group,https://leetcode.com/problems/reverse-nodes-in-k-group/,"Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.

k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.

You may not alter the values in the list's nodes, only nodes themselves may be changed.

Follow-up: Can you solve the problem in O(1) extra memory space?

","Example 1:


Input: head = [1,2,3,4,5], k = 2
Output: [2,1,4,3,5]
Example 2:


Input: head = [1,2,3,4,5], k = 3
Output: [3,2,1,4,5]
",Hard,Linked List,Linked List,,925.1K,1.6M,58.80%,96,,X,,X,,X
180,Flatten a Multilevel Doubly Linked List,https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/,,,Medium,Linked List,Linked List,,,,,,,,,,,
181,Find the Duplicate Number,https://leetcode.com/problems/find-the-duplicate-number/,,,Medium,Linked List,Linked List,,,,,,,X,,,,X
182,Partition List,https://leetcode.com/problems/partition-list/,,,Medium,Linked List,Linked List,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,
184,Insert Interval,https://leetcode.com/problems/insert-interval/,"You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.

Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).

Return intervals after the insertion.

Note that you don't need to modify intervals in-place. You can make a new array and return it.","Example 1:

Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
Example 2:

Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
 

Constraints:

0 <= intervals.length <= 104
intervals[i].length == 2
0 <= starti <= endi <= 105
intervals is sorted by starti in ascending order.
newInterval.length == 2
0 <= start <= end <= 105",Medium,Intervals,Intervals,,1.1M,2.7M,41.50%,216,X,X,X,X,,X
185,Merge Intervals,https://leetcode.com/problems/merge-intervals/,,,Medium,Intervals,Intervals,,,,,,X,X,X,X,X,X
186,Non-Overlapping Intervals,https://leetcode.com/problems/non-overlapping-intervals/,,,Medium,Intervals,Intervals,,,,,,X,X,X,X,,X
187,Meeting Rooms,https://leetcode.com/problems/meeting-rooms/,,,Easy,Intervals,Intervals,,,,,,X,X,X,X,,X
188,Meeting Rooms 2,https://leetcode.com/problems/meeting-rooms-ii/,,,Medium,Intervals,Intervals,,,,,,X,X,X,X,X,X
189,Interval List Intersections,https://leetcode.com/problems/interval-list-intersections/,,,Medium,Intervals,Intervals,,,,,,,,,,,X
190,Employee Free Time,https://leetcode.com/problems/employee-free-time/,,,Hard,Intervals,Intervals,,,,,,,,,X,,X
191,Minimum Interval to Include Each Query,https://leetcode.com/problems/minimum-interval-to-include-each-query/,"You are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1.

You are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1.

Return an array containing the answers to the queries.","Example 1:

Input: intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]
Output: [3,3,1,4]
Explanation: The queries are processed as follows:
- Query = 2: The interval [2,4] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3.
- Query = 3: The interval [2,4] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3.
- Query = 4: The interval [4,4] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1.
- Query = 5: The interval [3,6] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4.
Example 2:

Input: intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]
Output: [2,-1,4,6]
Explanation: The queries are processed as follows:
- Query = 2: The interval [2,3] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2.
- Query = 19: None of the intervals contain 19. The answer is -1.
- Query = 5: The interval [2,5] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4.
- Query = 22: The interval [20,25] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6.
",Hard,Intervals,"Intervals, Heaps, Line Sweep, Binary Search",,32.3K,65.2K,49.40%,8,,X,,,,
,,,,,,,,,,,,,,,,,,
193,Top K Frequent Elements,https://leetcode.com/problems/top-k-frequent-elements/,,,Medium,Arrays & Hashing,Heap,,,,,,X,X,X,,,X
194,Merge K Sorted Lists,https://leetcode.com/problems/merge-k-sorted-lists/,,,Hard,Heap,Heap,,,,,,X,X,X,X,X,X
195,Find Median from Data Stream,https://leetcode.com/problems/find-median-from-data-stream/,,,Hard,Heap,Heap,,,,,,X,X,X,X,X,X
196,Top K Frequent Words,https://leetcode.com/problems/top-k-frequent-words/,,,Medium,Heap,Heap,,,,,,,,,X,,
197,Kth Largest Element in an Array,https://leetcode.com/problems/kth-largest-element-in-an-array/,,,Medium,Heap,Heap,,,,,,,X,,X,,X
198,Kth Largest Element in a Stream,https://leetcode.com/problems/kth-largest-element-in-a-stream/,"Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.

Implement KthLargest class:

KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.
int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.","Example 1:

Input
[""KthLargest"", ""add"", ""add"", ""add"", ""add"", ""add""]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
Output
[null, 4, 5, 5, 8, 8]

Explanation
KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // return 4
kthLargest.add(5);   // return 5
kthLargest.add(10);  // return 5
kthLargest.add(9);   // return 8
kthLargest.add(4);   // return 8
 

Constraints:

1 <= k <= 104
0 <= nums.length <= 104
-104 <= nums[i] <= 104
-104 <= val <= 104
At most 104 calls will be made to add.
It is guaranteed that there will be at least k elements in the array when you search for the kth element.",Easy,Heap,"Heap, Data Stream",,541.2K,952.6K,56.80%,76,,X,,,,
199,Last Stone Weight,https://leetcode.com/problems/last-stone-weight/,,,Easy,Heap,Heap,,,,,,,X,,,,
200,The Skyline Problem,https://leetcode.com/problems/the-skyline-problem/discuss/61261/10-line-Python-solution-104-ms,,,Hard,Heap,Heap,,,,,,,,,,X,
201,K Closest Points to Origin,https://leetcode.com/problems/k-closest-points-to-origin/,,,Medium,Heap,Heap,,,,,,,X,,X,,X
202,Course Schedule 3,https://leetcode.com/problems/course-schedule-iii/,,,Hard,Heap,Heap,,,,,,,,,,,X
203,Find K Pairs with Smallest Sums,https://leetcode.com/problems/find-k-pairs-with-smallest-sums/,,,Medium,Heap,Heap,,,,,,,,,,,X
204,Sort Characters By Frequency,https://leetcode.com/problems/sort-characters-by-frequency/,"Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.

Return the sorted string. If there are multiple answers, return any of them.

","Example 1:

Input: s = ""tree""
Output: ""eert""
Explanation: 'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore ""eetr"" is also a valid answer.
Example 2:

Input: s = ""cccaaa""
Output: ""aaaccc""
Explanation: Both 'c' and 'a' appear three times, so both ""cccaaa"" and ""aaaccc"" are valid answers.
Note that ""cacaca"" is incorrect, as the same characters must be together.
Example 3:

Input: s = ""Aabb""
Output: ""bbAa""
Explanation: ""bbaA"" is also a valid answer, but ""Aabb"" is incorrect.
Note that 'A' and 'a' are treated as two different characters.
 

Constraints:

1 <= s.length <= 5 * 105
s consists of uppercase and lowercase English letters and digits.",Medium,Heap,"Heap, Bucket Sort, Hash Table",,732.5K,1M,72.60%,105,,,,,,X
205,"Smallest Range Covering Elements 
from K Lists",https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/,,,Hard,Heap,Heap,,,,,,,,,X,,X
206,Sliding Window Median,https://leetcode.com/problems/sliding-window-median/,,,Hard,Heap,Heap,,,,,,,,,,,X
,,,,,,,,,,,,,,,,,,
208,Binary Tree Paths,https://leetcode.com/problems/binary-tree-paths/,,,Easy,Tree,Tree,,,,,,,,,,,
209,Minimum Depth of Binary Tree,https://leetcode.com/problems/minimum-depth-of-binary-tree/,,,Easy,Tree,Tree,,,,,,,,X,,,X
210,Maximum Depth of Binary Tree,https://leetcode.com/problems/maximum-depth-of-binary-tree/,"Given the root of a binary tree, return its maximum depth.

A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.","Example 1:


Input: root = [3,9,20,null,null,15,7]
Output: 3
Example 2:

Input: root = [1,null,2]
Output: 2
",Easy,Tree,"Tree, DFS, BFS",,3.1M,4.1M,75.40%,120,X,X,,X,X,X
211,Invert Binary Tree,https://leetcode.com/problems/invert-binary-tree/,,,Easy,Tree,Tree,,,,,,X,X,X,X,,X
212,Binary Tree Level Order Traversal,https://leetcode.com/problems/binary-tree-level-order-traversal/,,,Medium,Tree,Tree,,,,,,X,X,X,X,X,X
213,Binary Tree Level Order Traversal 2,https://leetcode.com/problems/binary-tree-level-order-traversal-ii/,,,Medium,Tree,Tree,,,,,,,,,,,X
214,Binary Tree Zigzag Level Order Traversal,https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/,,,Medium,Tree,Tree,,,,,,,,,X,,X
215,Validate BST,https://leetcode.com/problems/validate-binary-search-tree/,"Given the root of a binary tree, determine if it is a valid binary search tree (BST).

A valid BST is defined as follows:

The left  subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.","Example 1:


Input: root = [2,1,3]
Output: true
Example 2:


Input: root = [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.",Medium,Tree,"Tree, DFS, BST",,2.3M,7.1M,33.00%,146,X,X,X,X,X,X
216,Same Tree,https://leetcode.com/problems/same-tree/,,,Easy,Tree,Tree,,,,,,X,X,X,X,,X
217,Subtree of Another Tree,https://leetcode.com/problems/subtree-of-another-tree/,,,Easy,Tree,Tree,,,,,,X,X,X,X,,X
218,Symmetric Tree,https://leetcode.com/problems/symmetric-tree/,,,Easy,Tree,Tree,,,,,,,,,X,,
219,Lowest Common Ancestor of BST,https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/,,,Easy,Tree,Tree,,,,,,X,X,X,X,,X
220,LCA of Binary Tree ,https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/,"Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”","Example 1:


Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
Example 2:


Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
Example 3:

Input: root = [1,2], p = 1, q = 2
Output: 1
 

Constraints:

The number of nodes in the tree is in the range [2, 105].
-109 <= Node.val <= 109
All Node.val are unique.
p != q
p and q will exist in the tree.",Medium,Tree,"Tree, DFS",,1.6M,2.6M,62.30%,70,,,,X,X,
221,LCA of Binary Tree 3,https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/,,,Medium,Tree,Tree,,,,,,,,,,X,
222,Kth Smallest Element in a BST,https://leetcode.com/problems/kth-smallest-element-in-a-bst/,,,Medium,Tree,Tree,,,,,,X,X,X,X,,
223,Convert Sorted Array to BST,https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/,,,Easy,Tree,Tree,,,,,,,,,X,X,
224,"Construct Binary Tree from 
Preorder/Inorder Traversal",https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/,"Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.

","Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
Example 2:

Input: preorder = [-1], inorder = [-1]
Output: [-1]
 

Constraints:

1 <= preorder.length <= 3000
inorder.length == preorder.length
-3000 <= preorder[i], inorder[i] <= 3000
preorder and inorder consist of unique values.
Each value of inorder also appears in preorder.
preorder is guaranteed to be the preorder traversal of the tree.
inorder is guaranteed to be the inorder traversal of the tree.",Medium,Tree,"Tree, Hash Table, Divide and Conquer, Binary Tree",,1.2M,1.9M,64.00%,79,X,X,X,X,,X
225,Serialize and Deserialize Binary Tree,https://leetcode.com/problems/serialize-and-deserialize-binary-tree/,,,Hard,Tree,Tree,,,,,,X,X,X,X,X,X
226,Binary Tree Maximum Path Sum,https://leetcode.com/problems/binary-tree-maximum-path-sum/,,,Hard,Tree,Tree,,,,,,X,X,X,X,,X
227,Implement Trie (Prefix Tree),https://leetcode.com/problems/implement-trie-prefix-tree/,,,Medium,Tree,Tree,,,,,,X,X,X,X,X,X
228,Design Add and Search Words Data Structure,https://leetcode.com/problems/design-add-and-search-words-data-structure/,"Design a data structure that supports adding new words and finding if a string matches any previously added string.

Implement the WordDictionary class:

WordDictionary() Initializes the object.
void addWord(word) Adds word to the data structure, it can be matched later.
bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.","Example:

Input
[""WordDictionary"",""addWord"",""addWord"",""addWord"",""search"",""search"",""search"",""search""]
[[],[""bad""],[""dad""],[""mad""],[""pad""],[""bad""],["".ad""],[""b..""]]
Output
[null,null,null,null,false,true,true,true]

Explanation
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord(""bad"");
wordDictionary.addWord(""dad"");
wordDictionary.addWord(""mad"");
wordDictionary.search(""pad""); // return False
wordDictionary.search(""bad""); // return True
wordDictionary.search("".ad""); // return True
wordDictionary.search(""b..""); // return True
 

Constraints:

1 <= word.length <= 25
word in addWord consists of lowercase English letters.
word in search consist of '.' or lowercase English letters.
There will be at most 2 dots in word for search queries.
At most 104 calls will be made to addWord and search.",Medium,Trie,"Tree, Trie, DFS, Design/OOD",,635.9K,1.4M,45.30%,71,X,X,X,X,,
229,Binary Tree Inorder Traversal,https://leetcode.com/problems/binary-tree-inorder-traversal/,,,Easy,Tree,Tree,,,,,,,,,,X,
230,Inorder Successor in BST,https://leetcode.com/problems/inorder-successor-in-bst/,,,Medium,Tree,Tree,,,,,,,,,,,
231,Populating Next Right Pointers in Each Node,https://leetcode.com/problems/populating-next-right-pointers-in-each-node/,"You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

Follow-up:

You may only use constant extra space.
The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.","Example 1:


Input: root = [1,2,3,4,5,6,7]
Output: [1,#,2,3,#,4,5,6,7,#]
Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.
Example 2:

Input: root = []
Output: []",Medium,Tree,"Tree, Linked List, DFS, BFS",,1M,1.7M,62.80%,52,,,,,X,X
232,Populating Next Right Pointers 2,https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/,,,Medium,Tree,Tree,,,,,,,,,,,X
233,Path Sum,https://leetcode.com/problems/path-sum/,,,Easy,Tree,Tree,,,,,,,,,,,X
234,Path Sum 2,https://leetcode.com/problems/path-sum-ii/,,,Medium,Tree,Tree,,,,,,,,,X,,X
235,Path Sum 3,https://leetcode.com/problems/path-sum-iii/,"Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.

The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).

","Example 1:


Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
Output: 3
Explanation: The paths that sum to 8 are shown.
Example 2:

Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
Output: 3
",Medium,,"Tree, DFS, Binary Tree",,558.9K,1.2M,46.30%,72,,,,X,,X
236,Diameter of Binary Tree,https://leetcode.com/problems/diameter-of-binary-tree/,,,Easy,Tree,Tree,,,,,,,X,,X,,X
237,Maximum Width of Binary Tree,https://leetcode.com/problems/maximum-width-of-binary-tree/,,,Medium,Tree,Tree,,,,,,,,,X,,X
238,Merge Two Binary Trees,https://leetcode.com/problems/merge-two-binary-trees/,,,Easy,Tree,Tree,,,,,,,,,,,X
239,Binary Tree Right Side View,https://leetcode.com/problems/binary-tree-right-side-view/,"Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.","Example 1:


Input: root = [1,2,3,null,5,null,4]
Output: [1,3,4]
Example 2:

Input: root = [1,null,3]
Output: [1,3]
Example 3:

Input: root = []
Output: []",Medium,Tree,"Tree, DFS, BFS",,1.3M,2.1M,63.10%,108,,X,,X,,X
240,All Nodes Distance K in Binary Tree,https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/,,,Medium,Tree,Tree,,,,,,,,,X,,X
241,Average of Levels in Binary Tree,https://leetcode.com/problems/average-of-levels-in-binary-tree/,,,Easy,Tree,Tree,,,,,,,,,,,X
242,Maximum Binary Tree,https://leetcode.com/problems/maximum-binary-tree/,,,Medium,Tree,Tree,,,,,,,,,,,X
243,Count Good Nodes in Binary Tree,https://leetcode.com/problems/count-good-nodes-in-binary-tree/,,,Medium,Tree,Tree,,,,,,,X,,,,
244,Balanced Binary Tree,https://leetcode.com/problems/balanced-binary-tree/,"Given a binary tree, determine if it is 
height-balanced

","
Example 1:


Input: root = [3,9,20,null,null,15,7]
Output: true
Example 2:


Input: root = [1,2,2,3,3,null,null,4,4]
Output: false
Example 3:

Input: root = []
Output: true",Easy,Tree,"Tree, DFS, Binary Tree",210,1.5M,2.8M,52.20%,79,,X,,X,,
245,Sum Root to Leaf Numbers,https://leetcode.com/problems/sum-root-to-leaf-numbers/,"You are given the root of a binary tree containing digits from 0 to 9 only.

Each root-to-leaf path in the tree represents a number.

For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.

A leaf node is a node with no children.","Example 1:


Input: root = [1,2,3]
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
Example 2:


Input: root = [4,9,0,5,1]
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.",Medium,Tree,"Tree, DFS, Binary Tree","233, 226",879.8K,1.3M,65.90%,119,,,,,,
246,House Robber 3,https://leetcode.com/problems/house-robber-iii/,"The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.

Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.

Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.","Example 1:


Input: root = [3,2,3,null,3,null,1]
Output: 7
Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
Example 2:


Input: root = [3,4,5,1,3,null,1]
Output: 9
Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.",Medium,1D DP,"Tree, DP, DFS, Binary Tree","324, 325",381K,702.1K,54.30%,48,,,,,,
247,Flip Equivalent Binary Trees,https://leetcode.com/problems/flip-equivalent-binary-trees/,"For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.

A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.

Given the roots of two binary trees root1 and root2, return true if the two trees are flip equivalent or false otherwise.

","Example 1:

Flipped Trees Diagram
Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]
Output: true
Explanation: We flipped at nodes with values 1, 3, and 5.
Example 2:

Input: root1 = [], root2 = []
Output: true
Example 3:

Input: root1 = [], root2 = [1]
Output: false
 

Constraints:

The number of nodes in each tree is in the range [0, 100].
Each tree will have unique node values in the range [0, 99].",Medium,Tree,Tree,,146.6K,219K,67.00%,8,,,,,,
248,Flatten Binary Tree to Linked List,https://leetcode.com/problems/flatten-binary-tree-to-linked-list/,"Given the root of a binary tree, flatten the tree into a ""linked list"":

The ""linked list"" should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.
The ""linked list"" should be in the same order as a pre-order traversal of the binary tree.

Follow up: Can you flatten the tree in-place (with O(1) extra space)?
","Example 1:


Input: root = [1,2,5,3,4,null,6]
Output: [1,null,2,null,3,null,4,null,5,null,6]
Example 2:

Input: root = []
Output: []
Example 3:

Input: root = [0]
Output: [0]
 

Constraints:

The number of nodes in the tree is in the range [0, 2000].
-100 <= Node.val <= 100
 ",Medium,Tree,Tree,,949.3K,1.5M,65.00%,57,,,,,,
249,Find Bottom Left Tree Value,https://leetcode.com/problems/find-bottom-left-tree-value/,"Given the root of a binary tree, return the leftmost value in the last row of the tree.

","Example 1:


Input: root = [2,1,3]
Output: 1
Example 2:


Input: root = [1,2,3,4,null,5,6,null,null,7]
Output: 7
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
-231 <= Node.val <= 231 - 1",Medium,Tree,Tree,,357.7K,502.7K,71.20%,114,,,,,,
250,Trim a Binary Search Tree,https://leetcode.com/problems/trim-a-binary-search-tree/,"Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node's descendant should remain a descendant). It can be proven that there is a unique answer.

Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.","Example 1:


Input: root = [1,0,2], low = 1, high = 2
Output: [1,null,2]
Example 2:


Input: root = [3,0,4,null,2,null,null,1], low = 1, high = 3
Output: [3,2,null,1]
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
0 <= Node.val <= 104
The value of each node in the tree is unique.
root is guaranteed to be a valid binary search tree.
0 <= low <= high <= 104",Medium,Tree,Tree,,293.3K,442.7K,66.30%,19,,,,,,
,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,
253,Clone Graph,https://leetcode.com/problems/clone-graph/,"Given a reference of a node in a connected undirected graph.

Return a deep copy (clone) of the graph.

Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.

class Node {
    public int val;
    public List<Node> neighbors;
}
 

Test case format:

For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.

An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.

The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.","Example 1:


Input: adjList = [[2,4],[1,3],[2,4],[1,3]]
Output: [[2,4],[1,3],[2,4],[1,3]]
Explanation: There are 4 nodes in the graph.
1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
Example 2:


Input: adjList = [[]]
Output: [[]]
Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.
Example 3:

Input: adjList = []
Output: []
Explanation: This an empty graph, it does not have any nodes.
 

Constraints:

The number of nodes in the graph is in the range [0, 100].
1 <= Node.val <= 100
Node.val is unique for each node.
There are no repeated edges and no self-loops in the graph.
The Graph is connected and all nodes can be visited starting from the given node.",Medium,Graph,"Graph, DFS, BFS, Union Find, Hash Table",,1.2M,2.2M,57.50%,128,X,X,X,X,,X
254,Pacific Atlantic Water Flow,https://leetcode.com/problems/pacific-atlantic-water-flow/,"There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.

The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).

The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.

Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.

","Example 1:


Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
Explanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:
[0,4]: [0,4] -> Pacific Ocean 
       [0,4] -> Atlantic Ocean
[1,3]: [1,3] -> [0,3] -> Pacific Ocean 
       [1,3] -> [1,4] -> Atlantic Ocean
[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean 
       [1,4] -> Atlantic Ocean
[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean 
       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean
[3,0]: [3,0] -> Pacific Ocean 
       [3,0] -> [4,0] -> Atlantic Ocean
[3,1]: [3,1] -> [3,0] -> Pacific Ocean 
       [3,1] -> [4,1] -> Atlantic Ocean
[4,0]: [4,0] -> Pacific Ocean 
       [4,0] -> Atlantic Ocean
Note that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.
Example 2:

Input: heights = [[1]]
Output: [[0,0]]
Explanation: The water can flow from the only cell to the Pacific and Atlantic oceans.
 

Constraints:

m == heights.length
n == heights[r].length
1 <= m, n <= 200
0 <= heights[r][c] <= 105",Medium,Graph,Graph,,467.4K,845.4K,55.30%,72,X,X,X,X,,X
255,Number of Islands,https://leetcode.com/problems/number-of-islands/,"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.

An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.","Example 1:

Input: grid = [
  [""1"",""1"",""1"",""1"",""0""],
  [""1"",""1"",""0"",""1"",""0""],
  [""1"",""1"",""0"",""0"",""0""],
  [""0"",""0"",""0"",""0"",""0""]
]
Output: 1
Example 2:

Input: grid = [
  [""1"",""1"",""0"",""0"",""0""],
  [""1"",""1"",""0"",""0"",""0""],
  [""0"",""0"",""1"",""0"",""0""],
  [""0"",""0"",""0"",""1"",""1""]
]
Output: 3
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 300
grid[i][j] is '0' or '1'.",Medium,Graph,Graph,,2.7M,4.6M,59.60%,184,X,X,X,X,X,X
256,Max Area of Island,https://leetcode.com/problems/max-area-of-island/,"You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

The area of an island is the number of cells with a value 1 in the island.

Return the maximum area of an island in grid. If there is no island, return 0.

","Example 1:


Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
Output: 6
Explanation: The answer is not 11, because the island must be connected 4-directionally.
Example 2:

Input: grid = [[0,0,0,0,0,0,0,0]]
Output: 0
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 50
grid[i][j] is either 0 or 1.",Medium,Graph,Graph,,863.4K,1.2M,72.00%,41,,X,,,,
257,Graph Valid Tree,https://leetcode.com/problems/graph-valid-tree/,,,Medium,Graph,Graph,,,,,,X,X,X,X,,X
258,Number of Connected Components in an Undirected Graph,https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/,,,Medium,Graph,Graph,,,,,,X,X,X,X,,X
259,Word Search,https://leetcode.com/problems/word-search/,"Given an m x n grid of characters board and a string word, return true if word exists in the grid.

The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.

Follow up: Could you use search pruning to make your solution faster with a larger board?

","Example 1:


Input: board = [[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], word = ""ABCCED""
Output: true
Example 2:


Input: board = [[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], word = ""SEE""
Output: true
Example 3:


Input: board = [[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], word = ""ABCB""
Output: false
 

Constraints:

m == board.length
n = board[i].length
1 <= m, n <= 6
1 <= word.length <= 15
board and word consists of only lowercase and uppercase English letters.
",Medium,Graph,"Graph, Matrix, Backtracking",,1.7M,3.9M,42.80%,198,X,X,,X,,X
260,Word Search 2,https://leetcode.com/problems/word-search-ii/,"Given an m x n board of characters and a list of strings words, return all words on the board.

Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

","Example 1:


Input: board = [[""o"",""a"",""a"",""n""],[""e"",""t"",""a"",""e""],[""i"",""h"",""k"",""r""],[""i"",""f"",""l"",""v""]], words = [""oath"",""pea"",""eat"",""rain""]
Output: [""eat"",""oath""]
Example 2:


Input: board = [[""a"",""b""],[""c"",""d""]], words = [""abcb""]
Output: []
 

Constraints:

m == board.length
n == board[i].length
1 <= m, n <= 12
board[i][j] is a lowercase English letter.
1 <= words.length <= 3 * 104
1 <= words[i].length <= 10
words[i] consists of lowercase English letters.
All the strings of words are unique.",Hard,Graph,Graph,,657.3K,1.8M,36.30%,78,X,X,X,X,X,X
261,Word Squares,https://leetcode.com/problems/word-squares/,,,Hard,Graph,Graph,,,,,,,,,,,X
262,Course Schedule,https://leetcode.com/problems/course-schedule/,"There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return true if you can finish all courses. Otherwise, return false.

","Example 1:

Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
Example 2:

Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
 

Constraints:

1 <= numCourses <= 2000
0 <= prerequisites.length <= 5000
prerequisites[i].length == 2
0 <= ai, bi < numCourses
All the pairs prerequisites[i] are unique.",Medium,Graph,Graph,,1.6M,3.3M,46.80%,148,X,X,X,X,X,X
263,Course Schedule II,https://leetcode.com/problems/course-schedule-ii/,"There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.","Example 1:

Input: numCourses = 2, prerequisites = [[1,0]]
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].
Example 2:

Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].
Example 3:

Input: numCourses = 1, prerequisites = []
Output: [0]
 

Constraints:

1 <= numCourses <= 2000
0 <= prerequisites.length <= numCourses * (numCourses - 1)
prerequisites[i].length == 2
0 <= ai, bi < numCourses
ai != bi
All the pairs [ai, bi] are distinct.",Medium,Graph,Graph,,1M,3M,50.60%,,,X,,X,,X
264,Alien Dictionary,https://leetcode.com/problems/alien-dictionary/,,,Hard,Advanced Graph,Graph,,,,,,X,X,X,X,X,X
265,Longest Increasing Path in a Matrix,https://leetcode.com/problems/longest-increasing-path-in-a-matrix/,"Given an m x n integers matrix, return the length of the longest increasing path in matrix.

From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).","Example 1:


Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]
Output: 4
Explanation: The longest increasing path is [1, 2, 6, 9].
Example 2:


Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]
Output: 4
Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.
Example 3:

Input: matrix = [[1]]
Output: 1",Hard,Graph,"Graph, DP, DFS, BFS, Topological Sort, Memoization, Matrix",,524.3K,977.3K,53.70%,36,,,,X,X,
266,Flood Fill,https://leetcode.com/problems/flood-fill/,"An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.

You are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].

To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color.

Return the modified image after performing the flood fill.

","Example 1:


Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2
Output: [[2,2,2],[2,2,0],[2,0,1]]
Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.
Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.
Example 2:

Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0
Output: [[0,0,0],[0,0,0]]
Explanation: The starting pixel is already colored 0, so no changes are made to the image.
 

Constraints:

m == image.length
n == image[i].length
1 <= m, n <= 50
0 <= image[i][j], color < 216
0 <= sr < m
0 <= sc < n",Easy,Graph,Graph,,899.99K,1.4M,64.00%,113,,,,X,,
267,Shortest Path to Get Food,https://leetcode.com/problems/shortest-path-to-get-food/,,,Medium,Graph,Graph,,,,,,,,,X,,
268,Minimum Height Trees,https://leetcode.com/problems/minimum-height-trees/,"A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.

Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs).

Return a list of all MHTs' root labels. You can return the answer in any order.

The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.","Example 1:


Input: n = 4, edges = [[1,0],[1,2],[1,3]]
Output: [1]
Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.
Example 2:


Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
Output: [3,4]
 

Constraints:

1 <= n <= 2 * 104
edges.length == n - 1
0 <= ai, bi < n
ai != bi
All the pairs (ai, bi) are distinct.
The given input is guaranteed to be a tree and there will be no repeated edges.",Medium,Graph,Graph,,371.5K,899.6K,41.80%,121,,,,X,,X
269,Sequence Reconstruction,https://leetcode.com/problems/sequence-reconstruction/,,,Medium,Graph,Graph,,,,,,,,,,,X
270,"Sort Items by Groups Respecting 
Dependencies",https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/,"There are n items each belonging to zero or one of m groups where group[i] is the group that the i-th item belongs to and it's equal to -1 if the i-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.

Return a sorted list of the items such that:

The items that belong to the same group are next to each other in the sorted list.
There are some relations between these items where beforeItems[i] is a list containing all the items that should come before the i-th item in the sorted array (to the left of the i-th item).
Return any solution if there is more than one solution and return an empty list if there is no solution.

","Example 1:



Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]
Output: [6,3,4,1,5,2,0,7]
Example 2:

Input: n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]
Output: []
Explanation: This is the same as example 1 except that 4 needs to be before 6 in the sorted list.
 

Constraints:

1 <= m <= n <= 3 * 104
group.length == beforeItems.length == n
-1 <= group[i] <= m - 1
0 <= beforeItems[i].length <= n - 1
0 <= beforeItems[i][j] <= n - 1
i != beforeItems[i][j]
beforeItems[i] does not contain duplicates elements.",Hard,Graph,Graph,,53.9K,81.1K,66.50%,61,,,,,,X
271,Find the Celebrity,https://leetcode.com/problems/find-the-celebrity/,,,Medium,Graph,Graph,,,,,,,,,,X,
272,Word Ladder,https://leetcode.com/problems/word-ladder/,"A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:

Every adjacent pair of words differs by a single letter.
Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.
sk == endWord
Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.","Example 1:

Input: beginWord = ""hit"", endWord = ""cog"", wordList = [""hot"",""dot"",""dog"",""lot"",""log"",""cog""]
Output: 5
Explanation: One shortest transformation sequence is ""hit"" -> ""hot"" -> ""dot"" -> ""dog"" -> cog"", which is 5 words long.
Example 2:

Input: beginWord = ""hit"", endWord = ""cog"", wordList = [""hot"",""dot"",""dog"",""lot"",""log""]
Output: 0
Explanation: The endWord ""cog"" is not in wordList, therefore there is no valid transformation sequence.
 

Constraints:

1 <= beginWord.length <= 10
endWord.length == beginWord.length
1 <= wordList.length <= 5000
wordList[i].length == beginWord.length
beginWord, endWord, and wordList[i] consist of lowercase English letters.
beginWord != endWord
All the words in wordList are unique.",Hard,Graph,"Graph, Hash Table, String, BFS",,1.1M,2.7M,39.30%,131,,X,,X,X,
273,Word Ladder 2,https://leetcode.com/problems/word-ladder-ii/,"A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:

Every adjacent pair of words differs by a single letter.
Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.
sk == endWord
Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].

","Example 1:

Input: beginWord = ""hit"", endWord = ""cog"", wordList = [""hot"",""dot"",""dog"",""lot"",""log"",""cog""]
Output: [[""hit"",""hot"",""dot"",""dog"",""cog""],[""hit"",""hot"",""lot"",""log"",""cog""]]
Explanation: There are 2 shortest transformation sequences:
""hit"" -> ""hot"" -> ""dot"" -> ""dog"" -> ""cog""
""hit"" -> ""hot"" -> ""lot"" -> ""log"" -> ""cog""
Example 2:

Input: beginWord = ""hit"", endWord = ""cog"", wordList = [""hot"",""dot"",""dog"",""lot"",""log""]
Output: []
Explanation: The endWord ""cog"" is not in wordList, therefore there is no valid transformation sequence.
 

Constraints:

1 <= beginWord.length <= 5
endWord.length == beginWord.length
1 <= wordList.length <= 500
wordList[i].length == beginWord.length
beginWord, endWord, and wordList[i] consist of lowercase English letters.
beginWord != endWord
All the words in wordList are unique.
The sum of all shortest transformation sequences does not exceed 105.",Hard,Graph,Graph,,366.5K,1.3M,27.30%,40,,,,,,
274,Island Perimeter,https://leetcode.com/problems/island-perimeter/,"You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.

Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).

The island doesn't have ""lakes"", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.","Example 1:


Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
Output: 16
Explanation: The perimeter is the 16 yellow stripes in the image above.
Example 2:

Input: grid = [[1]]
Output: 4
Example 3:

Input: grid = [[1,0]]
Output: 4
 

Constraints:

row == grid.length
col == grid[i].length
1 <= row, col <= 100
grid[i][j] is 0 or 1.
There is exactly one island in grid.",Easy,Graph,Graph,,625.8K,861.8K,72.60%,128,,,,,,
275,Accounts Merge,https://leetcode.com/problems/accounts-merge/,"Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.

Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.

After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.","Example 1:

Input: accounts = [[""John"",""johnsmith@mail.com"",""john_newyork@mail.com""],[""John"",""johnsmith@mail.com"",""john00@mail.com""],[""Mary"",""mary@mail.com""],[""John"",""johnnybravo@mail.com""]]
Output: [[""John"",""john00@mail.com"",""john_newyork@mail.com"",""johnsmith@mail.com""],[""Mary"",""mary@mail.com""],[""John"",""johnnybravo@mail.com""]]
Explanation:
The first and second John's are the same person as they have the common email ""johnsmith@mail.com"".
The third John and Mary are different people as none of their email addresses are used by other accounts.
We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], 
['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.
Example 2:

Input: accounts = [[""Gabe"",""Gabe0@m.co"",""Gabe3@m.co"",""Gabe1@m.co""],[""Kevin"",""Kevin3@m.co"",""Kevin5@m.co"",""Kevin0@m.co""],[""Ethan"",""Ethan5@m.co"",""Ethan4@m.co"",""Ethan0@m.co""],[""Hanzo"",""Hanzo3@m.co"",""Hanzo1@m.co"",""Hanzo0@m.co""],[""Fern"",""Fern5@m.co"",""Fern1@m.co"",""Fern0@m.co""]]
Output: [[""Ethan"",""Ethan0@m.co"",""Ethan4@m.co"",""Ethan5@m.co""],[""Gabe"",""Gabe0@m.co"",""Gabe1@m.co"",""Gabe3@m.co""],[""Hanzo"",""Hanzo0@m.co"",""Hanzo1@m.co"",""Hanzo3@m.co""],[""Kevin"",""Kevin0@m.co"",""Kevin3@m.co"",""Kevin5@m.co""],[""Fern"",""Fern0@m.co"",""Fern1@m.co"",""Fern5@m.co""]]
 

Constraints:

1 <= accounts.length <= 1000
2 <= accounts[i].length <= 10
1 <= accounts[i][j].length <= 30
accounts[i][0] consists of English letters.
accounts[i][j] (for j > 0) is a valid email.",Medium,Graph,Graph,,388.3K,678.5K,57.20%,59,,,,X,,
276,Minimum Knights Move,https://leetcode.com/problems/minimum-knight-moves/,,,Medium,Graph,Graph,,,,,,,,,X,,
277,Redundant Connection,https://leetcode.com/problems/redundant-connection/,"In this problem, a tree is an undirected graph that is connected and has no cycles.

You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.

Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.","Example 1:


Input: edges = [[1,2],[1,3],[2,3]]
Output: [2,3]
Example 2:


Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]
Output: [1,4]
 

Constraints:

n == edges.length
3 <= n <= 1000
edges[i].length == 2
1 <= ai < bi <= edges.length
ai != bi
There are no repeated edges.
The given graph is connected.",Medium,Graph,"Graph, DFS, BFS, Union Find",,356.9K,567.4K,62.90%,33,,X,,,,
278,Count Sub Islands,https://leetcode.com/problems/count-sub-islands/,"You are given two m x n binary matrices grid1 and grid2 containing only 0's (representing water) and 1's (representing land). An island is a group of 1's connected 4-directionally (horizontal or vertical). Any cells outside of the grid are considered water cells.

An island in grid2 is considered a sub-island if there is an island in grid1 that contains all the cells that make up this island in grid2.

Return the number of islands in grid2 that are considered sub-islands.","Example 1:


Input: grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
Output: 3
Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.
The 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands.
Example 2:


Input: grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
Output: 2 
Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2.
The 1s colored red in grid2 are those considered to be part of a sub-island. There are two sub-islands.
 

Constraints:

m == grid1.length == grid2.length
n == grid1[i].length == grid2[i].length
1 <= m, n <= 500
grid1[i][j] and grid2[i][j] are either 0 or 1.",Medium,Graph,Graph,,91.2K,135.5K,67.30%,16,,,,,,
279,Walls and Gates,https://leetcode.com/problems/walls-and-gates/,,,Medium,Graph,Graph,,,,,,,X,,,,
280,Surrounded Regions,https://leetcode.com/problems/surrounded-regions/,"Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.","Example 1:


Input: board = [[""X"",""X"",""X"",""X""],[""X"",""O"",""O"",""X""],[""X"",""X"",""O"",""X""],[""X"",""O"",""X"",""X""]]
Output: [[""X"",""X"",""X"",""X""],[""X"",""X"",""X"",""X""],[""X"",""X"",""X"",""X""],[""X"",""O"",""X"",""X""]]
Explanation: Notice that an 'O' should not be flipped if:
- It is on the border, or
- It is adjacent to an 'O' that should not be flipped.
The bottom 'O' is on the border, so it is not flipped.
The other three 'O' form a surrounded region, so they are flipped.
Example 2:

Input: board = [[""X""]]
Output: [[""X""]]
 

Constraints:

m == board.length
n == board[i].length
1 <= m, n <= 200
board[i][j] is 'X' or 'O'.",Medium,Graph,Graph,,705.2K,1.8M,39.60%,95,,X,,,,
281,Reconstruct Itinerary,https://leetcode.com/problems/reconstruct-itinerary/,"You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.

All of the tickets belong to a man who departs from ""JFK"", thus, the itinerary must begin with ""JFK"". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.

For example, the itinerary [""JFK"", ""LGA""] has a smaller lexical order than [""JFK"", ""LGB""].
You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.","Example 1:


Input: tickets = [[""MUC"",""LHR""],[""JFK"",""MUC""],[""SFO"",""SJC""],[""LHR"",""SFO""]]
Output: [""JFK"",""MUC"",""LHR"",""SFO"",""SJC""]
Example 2:


Input: tickets = [[""JFK"",""SFO""],[""JFK"",""ATL""],[""SFO"",""ATL""],[""ATL"",""JFK""],[""ATL"",""SFO""]]
Output: [""JFK"",""ATL"",""JFK"",""SFO"",""ATL"",""SFO""]
Explanation: Another possible reconstruction is [""JFK"",""SFO"",""ATL"",""JFK"",""ATL"",""SFO""] but it is larger in lexical order.
 

Constraints:

1 <= tickets.length <= 300
tickets[i].length == 2
fromi.length == 3
toi.length == 3
fromi and toi consist of uppercase English letters.
fromi != toi",Hard,Advanced Graph,Graph,,428.6K,991.1K,43.20%,99,,X,,,,
282,Rotting Oranges,https://leetcode.com/problems/rotting-oranges/,"You are given an m x n grid where each cell can have one of three values:

0 representing an empty cell,
1 representing a fresh orange, or
2 representing a rotten orange.
Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.

Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.","Example 1:


Input: grid = [[2,1,1],[1,1,0],[0,1,1]]
Output: 4
Example 2:

Input: grid = [[2,1,1],[0,1,1],[1,0,1]]
Output: -1
Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.
Example 3:

Input: grid = [[0,2]]
Output: 0
Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0.
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 10
grid[i][j] is 0, 1, or 2.",Medium,Graph,Graph,,843.7K,1.6M,54.10%,70,,X,,X,,
283,Snakes and Ladders,https://leetcode.com/problems/snakes-and-ladders/,"You are given an n x n integer matrix board where the cells are labeled from 1 to n2 in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row.

You start on square 1 of the board. In each move, starting from square curr, do the following:

Choose a destination square next with a label in the range [curr + 1, min(curr + 6, n2)].
This choice simulates the result of a standard 6-sided die roll: i.e., there are always at most 6 destinations, regardless of the size of the board.
If next has a snake or ladder, you must move to the destination of that snake or ladder. Otherwise, you move to next.
The game ends when you reach the square n2.
A board square on row r and column c has a snake or ladder if board[r][c] != -1. The destination of that snake or ladder is board[r][c]. Squares 1 and n2 do not have a snake or ladder.

Note that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do not follow the subsequent snake or ladder.

For example, suppose the board is [[-1,4],[-1,3]], and on the first move, your destination square is 2. You follow the ladder to square 3, but do not follow the subsequent ladder to 4.
Return the least number of moves required to reach the square n2. If it is not possible to reach the square, return -1.","Example 1:


Input: board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]
Output: 4
Explanation: 
In the beginning, you start at square 1 (at row 5, column 0).
You decide to move to square 2 and must take the ladder to square 15.
You then decide to move to square 17 and must take the snake to square 13.
You then decide to move to square 14 and must take the ladder to square 35.
You then decide to move to square 36, ending the game.
This is the lowest possible number of moves to reach the last square, so return 4.
Example 2:

Input: board = [[-1,-1],[-1,3]]
Output: 1
 

Constraints:

n == board.length == board[i].length
2 <= n <= 20
board[i][j] is either -1 or in the range [1, n2].
The squares labeled 1 and n2 do not have any ladders or snakes.",Medium,Graph,Graph,,184.7K,421.9K,43.80%,158,,,,,,
284,Open the Lock,https://leetcode.com/problems/open-the-lock/,"You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.

The lock initially starts at '0000', a string representing the state of the 4 wheels.

You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.

Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.

","Example 1:

Input: deadends = [""0201"",""0101"",""0102"",""1212"",""2002""], target = ""0202""
Output: 6
Explanation: 
A sequence of valid moves would be ""0000"" -> ""1000"" -> ""1100"" -> ""1200"" -> ""1201"" -> ""1202"" -> ""0202"".
Note that a sequence like ""0000"" -> ""0001"" -> ""0002"" -> ""0102"" -> ""0202"" would be invalid,
because the wheels of the lock become stuck after the display becomes the dead end ""0102"".
Example 2:

Input: deadends = [""8888""], target = ""0009""
Output: 1
Explanation: We can turn the last wheel in reverse to move from ""0000"" -> ""0009"".
Example 3:

Input: deadends = [""8887"",""8889"",""8878"",""8898"",""8788"",""8988"",""7888"",""9888""], target = ""8888""
Output: -1
Explanation: We cannot reach the target without getting stuck.
 

Constraints:

1 <= deadends.length <= 500
deadends[i].length == 4
target.length == 4
target will not be in the list deadends.
target and deadends[i] consist of digits only.",Medium,Graph,Graph,,317.6K,526.9K,60.30%,112,,,,,,
285,Bus Routes,https://leetcode.com/problems/bus-routes/,"You are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever.

For example, if routes[0] = [1, 5, 7], this means that the 0th bus travels in the sequence 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... forever.
You will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target. You can travel between bus stops by buses only.

Return the least number of buses you must take to travel from source to target. Return -1 if it is not possible.

","Example 1:

Input: routes = [[1,2,7],[3,6,7]], source = 1, target = 6
Output: 2
Explanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.
Example 2:

Input: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
Output: -1
 

 

Constraints:

1 <= routes.length <= 500.
1 <= routes[i].length <= 105
All the values of routes[i] are unique.
sum(routes[i].length) <= 105
0 <= routes[i][j] < 106
0 <= source, target < 106",Hard,Graph,"Graph, Array, Hash Table",,201.5K,421K,47.90%,81,,,,X,,
286,Reorder Routes to Make All Paths Lead to the City Zero,https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/,"There are n cities numbered from 0 to n - 1 and n - 1 roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.

Roads are represented by connections where connections[i] = [ai, bi] represents a road from city ai to city bi.

This year, there will be a big event in the capital (city 0), and many people want to travel to this city.

Your task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed.

It's guaranteed that each city can reach city 0 after reorder.","Example 1:


Input: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]
Output: 3
Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).
Example 2:


Input: n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]
Output: 2
Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).
Example 3:

Input: n = 3, connections = [[1,0],[2,0]]
Output: 0
 

Constraints:

2 <= n <= 5 * 104
connections.length == n - 1
connections[i].length == 2
0 <= ai, bi <= n - 1
ai != bi",Medium,Graph,Graph,,184.6K,286.5K,64.40%,63,,,,,,
287,Network Delay Time,https://leetcode.com/problems/network-delay-time/,"You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target.

We will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.

","Example 1:


Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
Output: 2
Example 2:

Input: times = [[1,2,1]], n = 2, k = 1
Output: 1
Example 3:

Input: times = [[1,2,1]], n = 2, k = 2
Output: -1
 

Constraints:

1 <= k <= n <= 100
1 <= times.length <= 6000
times[i].length == 3
1 <= ui, vi <= n
ui != vi
0 <= wi <= 100
All the pairs (ui, vi) are unique. (i.e., no multiple edges.)",Medium,Advanced Graph,Graph,,491K,911.4K,53.90%,37,,X,,,,
288,Swim in Rising Water,https://leetcode.com/problems/swim-in-rising-water/,"You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).

The rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.

Return the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).","Example 1:


Input: grid = [[0,2],[1,3]]
Output: 3
Explanation:
At time 0, you are in grid location (0, 0).
You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.
You cannot reach point (1, 1) until time 3.
When the depth of water is 3, we can swim anywhere inside the grid.
Example 2:


Input: grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
Output: 16
Explanation: The final route is shown.
We need to wait until time 16 so that (0, 0) and (4, 4) are connected.
 

Constraints:

n == grid.length
n == grid[i].length
1 <= n <= 50
0 <= grid[i][j] < n2
Each value grid[i][j] is unique.",Hard,Advanced Graph,Graph,,160.4K,263.8K,60.80%,29,,X,,,,
289,Cheapest Flights within K Stops,https://leetcode.com/problems/cheapest-flights-within-k-stops/,"There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.

You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.","Example 1:


Input: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1
Output: 700
Explanation:
The graph is shown above.
The optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.
Note that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.
Example 2:


Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1
Output: 200
Explanation:
The graph is shown above.
The optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.
Example 3:


Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0
Output: 500
Explanation:
The graph is shown above.
The optimal path with no stops from city 0 to 2 is marked in red and has cost 500.
 

Constraints:

1 <= n <= 100
0 <= flights.length <= (n * (n - 1) / 2)
flights[i].length == 3
0 <= fromi, toi < n
fromi != toi
1 <= pricei <= 104
There will not be any multiple flights between two cities.
0 <= src, dst, k < n
src != dst",Medium,Advanced Graph,Graph,,558K,1.4M,39.30%,155,,X,,X,,
290,Min Cost to Connect all Points,https://leetcode.com/problems/min-cost-to-connect-all-points/,"You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].

The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.

Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.","Example 1:


Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
Output: 20
Explanation: 

We can connect the points as shown above to get the minimum cost of 20.
Notice that there is a unique path between every pair of points.
Example 2:

Input: points = [[3,12],[-2,5],[-4,1]]
Output: 18
 

Constraints:

1 <= points.length <= 1000
-106 <= xi, yi <= 106
All pairs (xi, yi) are distinct.",Medium,Advanced Graph,"Graph, Union Find, Minimum Spanning Tree",,284.8K,426.8K,66.70%,52,,X,,,,
,,,,,,,,,,,,,,,,,,
292,LC Explore Backtracking Template,https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2793/,,,,,,,,,,,,,,,,
293,Subsets,https://leetcode.com/problems/subsets/,"Given an integer array nums of unique elements, return all possible 
subsets
 (the power set).

The solution set must not contain duplicate subsets. Return the solution in any order.

","Example 1:

Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
Example 2:

Input: nums = [0]
Output: [[],[0]]
 

Constraints:

1 <= nums.length <= 10
-10 <= nums[i] <= 10
All the numbers of nums are unique.",Medium,Backtracking,Backtrack,,1.9M,2.5M,78.30%,132,,X,,X,X,X
294,Subsets 2,https://leetcode.com/problems/subsets-ii/,"Given an integer array nums that may contain duplicates, return all possible 
subsets
 (the power set).

The solution set must not contain duplicate subsets. Return the solution in any order.

","Example 1:

Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]
Example 2:

Input: nums = [0]
Output: [[],[0]]
",Medium,Backtracking,Backtrack,,920.9K,1.5M,57.40%,60,,X,,,,X
295,Combinations,https://leetcode.com/problems/combinations/,"Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].

You may return the answer in any order.","Example 1:

Input: n = 4, k = 2
Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
Explanation: There are 4 choose 2 = 6 total combinations.
Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.
Example 2:

Input: n = 1, k = 1
Output: [[1]]
Explanation: There is 1 choose 1 = 1 total combination.
 

Constraints:

1 <= n <= 20
1 <= k <= n",Medium,Backtracking,Backtrack,,902.6K,1.3M,70.50%,68,,,,,X,X
296,Permutations,https://leetcode.com/problems/permutations/,"Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.","Example 1:

Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
Example 2:

Input: nums = [0,1]
Output: [[0,1],[1,0]]
Example 3:

Input: nums = [1]
Output: [[1]]
 

Constraints:

1 <= nums.length <= 6
-10 <= nums[i] <= 10
All the integers of nums are unique.",Medium,Backtracking,Backtrack,,2.1M,2.6M,78.40%,95,,X,,X,X,X
297,Permutations 2,https://leetcode.com/problems/permutations-ii/,"Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.

","Example 1:

Input: nums = [1,1,2]
Output:
[[1,1,2],
 [1,2,1],
 [2,1,1]]
Example 2:

Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
 

Constraints:

1 <= nums.length <= 8
-10 <= nums[i] <= 10",Medium,Backtracking,Backtrack,,929.6K,1.6M,59.30%,28,,,,,,X
298,Generate Parentheses,https://leetcode.com/problems/generate-parentheses/,"Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

","Example 1:

Input: n = 3
Output: [""((()))"",""(()())"",""(())()"",""()(())"",""()()()""]
Example 2:

Input: n = 1
Output: [""()""]",Medium,Backtracking,Backtrack,,1.8M,2.5M,74.60%,97,,X,,X,X,X
299,Letter Combinations of Phone Number,https://leetcode.com/problems/letter-combinations-of-a-phone-number/,"Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.

A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.","Example 1:

Input: digits = ""23""
Output: [""ad"",""ae"",""af"",""bd"",""be"",""bf"",""cd"",""ce"",""cf""]
Example 2:

Input: digits = """"
Output: []
Example 3:

Input: digits = ""2""
Output: [""a"",""b"",""c""]
 

Constraints:

0 <= digits.length <= 4
digits[i] is a digit in the range ['2', '9'].",Medium,Backtracking,Backtrack,,2M,3.3M,60.50%,156,,X,,X,X,X
300,Remove Invalid Parentheses,https://leetcode.com/problems/remove-invalid-parentheses/,"Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.

Return a list of unique strings that are valid with the minimum number of removals. You may return the answer in any order.","Example 1:

Input: s = ""()())()""
Output: [""(())()"",""()()()""]
Example 2:

Input: s = ""(a)())()""
Output: [""(a())()"",""(a)()()""]
Example 3:

Input: s = "")(""
Output: [""""]
 

Constraints:

1 <= s.length <= 25
s consists of lowercase English letters and parentheses '(' and ')'.
There will be at most 20 parentheses in s.",Hard,Backtracking,Backtrack,,431.1K,893.4K,48.30%,17,,,,,X,
301,N-Queens,https://leetcode.com/problems/n-queens/,"The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.

Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.

Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.

","Example 1:


Input: n = 4
Output: [["".Q.."",""...Q"",""Q..."",""..Q.""],[""..Q."",""Q..."",""...Q"","".Q..""]]
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above
Example 2:

Input: n = 1
Output: [[""Q""]]
 

Constraints:

1 <= n <= 9
",Hard,Backtracking,Backtrack,,723.7K,1.1M,68.40%,56,,X,,X,,X
302,Sudoku Solver,https://leetcode.com/problems/sudoku-solver/,"Write a program to solve a Sudoku puzzle by filling the empty cells.

A sudoku solution must satisfy all of the following rules:

Each of the digits 1-9 must occur exactly once in each row.
Each of the digits 1-9 must occur exactly once in each column.
Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.
The '.' character indicates empty cells.","Example 1:


Input: board = [[""5"",""3"",""."",""."",""7"",""."",""."",""."","".""],[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""],[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""],[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""],[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""],[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""],[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""],[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""],[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]]
Output: [[""5"",""3"",""4"",""6"",""7"",""8"",""9"",""1"",""2""],[""6"",""7"",""2"",""1"",""9"",""5"",""3"",""4"",""8""],[""1"",""9"",""8"",""3"",""4"",""2"",""5"",""6"",""7""],[""8"",""5"",""9"",""7"",""6"",""1"",""4"",""2"",""3""],[""4"",""2"",""6"",""8"",""5"",""3"",""7"",""9"",""1""],[""7"",""1"",""3"",""9"",""2"",""4"",""8"",""5"",""6""],[""9"",""6"",""1"",""5"",""3"",""7"",""2"",""8"",""4""],[""2"",""8"",""7"",""4"",""1"",""9"",""6"",""3"",""5""],[""3"",""4"",""5"",""2"",""8"",""6"",""1"",""7"",""9""]]
Explanation: The input board is shown above and the only valid solution is shown below:


 

Constraints:

board.length == 9
board[i].length == 9
board[i][j] is a digit or '.'.
It is guaranteed that the input board has only one solution.",Hard,Backtracking,Backtrack,,589.5K,961.7K,61.30%,65,,,,X,,X
303,Letter Case Permutation,https://leetcode.com/problems/letter-case-permutation/,"Given a string s, you can transform every letter individually to be lowercase or uppercase to create another string.

Return a list of all possible strings we could create. Return the output in any order.","Example 1:

Input: s = ""a1b2""
Output: [""a1b2"",""a1B2"",""A1b2"",""A1B2""]
Example 2:

Input: s = ""3z4""
Output: [""3z4"",""3Z4""]
 

Constraints:

1 <= s.length <= 12
s consists of lowercase English letters, uppercase English letters, and digits.",Medium,Backtracking,Backtrack,,301.3K,406K,74.20%,15,,,,,,X
304,Combination Sum,https://leetcode.com/problems/combination-sum/,"Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.

The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the 
frequency
 of at least one of the chosen numbers is different.

The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.","Example 1:

Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.
Example 2:

Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]
Example 3:

Input: candidates = [2], target = 1
Output: []
 

Constraints:

1 <= candidates.length <= 30
2 <= candidates[i] <= 40
All elements of candidates are distinct.
1 <= target <= 40",Medium,Backtracking,Backtrack,,1.9M,2.7M,71.60%,77,,X,,X,,X
305,Combination Sum 2,https://leetcode.com/problems/combination-sum-ii/,"Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.

Each number in candidates may only be used once in the combination.

Note: The solution set must not contain duplicate combinations.","Example 1:

Input: candidates = [10,1,2,7,6,1,5], target = 8
Output: 
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
Example 2:

Input: candidates = [2,5,2,1,2], target = 5
Output: 
[
[1,2,2],
[5]
]
 

Constraints:

1 <= candidates.length <= 100
1 <= candidates[i] <= 50
1 <= target <= 30",Medium,Backtracking,Backtrack,,975.3K,1.8M,54.60%,77,,X,,,,X
306,Combination Sum 3,https://leetcode.com/problems/combination-sum-iii/,"Find all valid combinations of k numbers that sum up to n such that the following conditions are true:

Only numbers 1 through 9 are used.
Each number is used at most once.
Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.

","Example 1:

Input: k = 3, n = 7
Output: [[1,2,4]]
Explanation:
1 + 2 + 4 = 7
There are no other valid combinations.
Example 2:

Input: k = 3, n = 9
Output: [[1,2,6],[1,3,5],[2,3,4]]
Explanation:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
There are no other valid combinations.
Example 3:

Input: k = 4, n = 1
Output: []
Explanation: There are no valid combinations.
Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination.
 

Constraints:

2 <= k <= 9
1 <= n <= 60",Medium,Backtracking,Backtrack,,512.5K,734.8K,69.70%,35,,,,,,X
307,Palindrome Partitioning,https://leetcode.com/problems/palindrome-partitioning/,"Given a string s, partition s such that every 
substring
 of the partition is a 
palindrome
. Return all possible palindrome partitioning of s.

","Example 1:

Input: s = ""aab""
Output: [[""a"",""a"",""b""],[""aa"",""b""]]
Example 2:

Input: s = ""a""
Output: [[""a""]]
 

Constraints:

1 <= s.length <= 16
s contains only lowercase English letters.",Medium,Backtracking,"Backtrack, DP",,801.4K,1.2M,67.70%,75,,X,,,,X
308,Generalized Abbreviation,https://leetcode.com/problems/generalized-abbreviation/,,,Medium,Backtracking,Backtrack,,,,,,,,,,,X
309,Partition to K Equal Sum Subsets,https://leetcode.com/problems/partition-to-k-equal-sum-subsets/,"Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.

","Example 1:

Input: nums = [4,3,2,3,5,2,1], k = 4
Output: true
Explanation: It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.
Example 2:

Input: nums = [1,2,3,4], k = 3
Output: false
 

Constraints:

1 <= k <= nums.length <= 16
1 <= nums[i] <= 104
The frequency of each element is in the range [1, 4].",Medium,Backtracking,Backtrack,,267.7K,698.2K,38.30%,55,,,,,,X
310,"Splitting a String into Descending 
Consecutive Values",https://leetcode.com/problems/splitting-a-string-into-descending-consecutive-values/,"You are given a string s that consists of only digits.

Check if we can split s into two or more non-empty substrings such that the numerical values of the substrings are in descending order and the difference between numerical values of every two adjacent substrings is equal to 1.

For example, the string s = ""0090089"" can be split into [""0090"", ""089""] with numerical values [90,89]. The values are in descending order and adjacent values differ by 1, so this way is valid.
Another example, the string s = ""001"" can be split into [""0"", ""01""], [""00"", ""1""], or [""0"", ""0"", ""1""]. However all the ways are invalid because they have numerical values [0,1], [0,1], and [0,0,1] respectively, all of which are not in descending order.
Return true if it is possible to split s​​​​​​ as described above, or false otherwise.

A substring is a contiguous sequence of characters in a string.","Example 1:

Input: s = ""1234""
Output: false
Explanation: There is no valid way to split s.
Example 2:

Input: s = ""050043""
Output: true
Explanation: s can be split into [""05"", ""004"", ""3""] with numerical values [5,4,3].
The values are in descending order with adjacent values differing by 1.
Example 3:

Input: s = ""9080701""
Output: false
Explanation: There is no valid way to split s.
 

Constraints:

1 <= s.length <= 20
s only consists of digits.",Medium,Backtracking,Backtrack,,25.6K,72.3K,35.50%,7,,,,,,
311,Find Unique Binary String,https://leetcode.com/problems/find-unique-binary-string/,"Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.","Example 1:

Input: nums = [""01"",""10""]
Output: ""11""
Explanation: ""11"" does not appear in nums. ""00"" would also be correct.
Example 2:

Input: nums = [""00"",""01""]
Output: ""11""
Explanation: ""11"" does not appear in nums. ""10"" would also be correct.
Example 3:

Input: nums = [""111"",""011"",""001""]
Output: ""101""
Explanation: ""101"" does not appear in nums. ""000"", ""010"", ""100"", and ""110"" would also be correct.
 

Constraints:

n == nums.length
1 <= n <= 16
nums[i].length == n
nums[i] is either '0' or '1'.
All the strings of nums are unique.",Medium,Backtracking,Backtrack,,137.4K,184.2K,74.6,71,,,,,,
312,"Maximum Length of a Concatenated 
String with Unique Characters",https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/,"You are given an array of strings arr. A string s is formed by the concatenation of a subsequence of arr that has unique characters.

Return the maximum possible length of s.

A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.

","Example 1:

Input: arr = [""un"",""iq"",""ue""]
Output: 4
Explanation: All the valid concatenations are:
- """"
- ""un""
- ""iq""
- ""ue""
- ""uniq"" (""un"" + ""iq"")
- ""ique"" (""iq"" + ""ue"")
Maximum length is 4.
Example 2:

Input: arr = [""cha"",""r"",""act"",""ers""]
Output: 6
Explanation: Possible longest valid concatenations are ""chaers"" (""cha"" + ""ers"") and ""acters"" (""act"" + ""ers"").
Example 3:

Input: arr = [""abcdefghijklmnopqrstuvwxyz""]
Output: 26
Explanation: The only string in arr has all 26 characters.
 

Constraints:

1 <= arr.length <= 16
1 <= arr[i].length <= 26
arr[i] contains only lowercase English letters.",Medium,Backtracking,Backtrack,,285.7K,528.3K,54.10%,85,,,,,,
313,Restore IP Addresses,https://leetcode.com/problems/restore-ip-addresses/,"A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.

For example, ""0.1.2.201"" and ""192.168.1.1"" are valid IP addresses, but ""0.011.255.245"", ""192.168.1.312"" and ""192.168@1.1"" are invalid IP addresses.
Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.

","Example 1:

Input: s = ""25525511135""
Output: [""255.255.11.135"",""255.255.111.35""]
Example 2:

Input: s = ""0000""
Output: [""0.0.0.0""]
Example 3:

Input: s = ""101023""
Output: [""1.0.10.23"",""1.0.102.3"",""10.1.0.23"",""10.10.2.3"",""101.0.2.3""]
 

Constraints:

1 <= s.length <= 20
s consists of digits only.",Medium,Backtracking,Backtrack,,459.4K,917.5K,50.10%,67,,,,,,
314,Matchsticks to Squares,https://leetcode.com/problems/matchsticks-to-square/,"You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.

Return true if you can make this square and false otherwise.","Example 1:


Input: matchsticks = [1,1,2,2,2]
Output: true
Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.
Example 2:

Input: matchsticks = [3,3,3,3,4]
Output: false
Explanation: You cannot find a way to form a square with all the matchsticks.
 

Constraints:

1 <= matchsticks.length <= 15
1 <= matchsticks[i] <= 108",Medium,Backtracking,Backtrack,,163.5K,406.4K,40.30%,19,,,,,,
,,,,,,,,,,,,,,,,,,
316,DP Thread on Leetcode,https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns,,,,,,,,,,,,,,,,
317,Coin Change,https://leetcode.com/problems/coin-change/,"You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.

Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

You may assume that you have an infinite number of each kind of coin.","Example 1:

Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
Example 2:

Input: coins = [2], amount = 3
Output: -1
Example 3:

Input: coins = [1], amount = 0
Output: 0",Medium,1D DP,"DP, Array, BFS",,1.8M,4.1M,44.00%,95,X,X,X,X,X,X
318,Coin Change 2,https://leetcode.com/problems/coin-change-2/,"You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.

Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.

You may assume that you have an infinite number of each kind of coin.

The answer is guaranteed to fit into a signed 32-bit integer.","Example 1:

Input: amount = 5, coins = [1,2,5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
Example 2:

Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.
Example 3:

Input: amount = 10, coins = [10]
Output: 1
 

Constraints:

1 <= coins.length <= 300
1 <= coins[i] <= 5000
All the values of coins are unique.
0 <= amount <= 5000",Medium,1D DP,"DP, Array",,615K,962.4K,63.90%,69,,X,,,,
319,Combination Sum 4,https://leetcode.com/problems/combination-sum-iv/,"Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.

The test cases are generated so that the answer can fit in a 32-bit integer.

Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?

","Example 1:

Input: nums = [1,2,3], target = 4
Output: 7
Explanation:
The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
Note that different sequences are counted as different combinations.
Example 2:

Input: nums = [9], target = 3
Output: 0
 

Constraints:

1 <= nums.length <= 200
1 <= nums[i] <= 1000
All the elements of nums are unique.
1 <= target <= 1000",Medium,,"DP, Array",,482.7K,891.1K,54.20%,81,X,,X,X,,X
320,Partition Equal Subset Sum,https://leetcode.com/problems/partition-equal-subset-sum/,"Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.

","Example 1:

Input: nums = [1,5,11,5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11].
Example 2:

Input: nums = [1,2,3,5]
Output: false
Explanation: The array cannot be partitioned into equal sum subsets.",Medium,,DP,,827.1K,1.8M,46.30%,74,,X,,X,,X
321,Minimum Path Sum,https://leetcode.com/problems/minimum-path-sum/,"Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

","Example 1:


Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.
Example 2:

Input: grid = [[1,2,3],[4,5,6]]
Output: 12
 

Constraints:

m == grid.length
n == grid[i].length
1 <= m, n <= 200
0 <= grid[i][j] <= 200",Medium,,DP,,1.2M,1.8M,64.00%,86,,,,,,
322,Min Cost Climbing Stairs,https://leetcode.com/problems/min-cost-climbing-stairs/,"You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.

You can either start from the step with index 0, or the step with index 1.

Return the minimum cost to reach the top of the floor.","Example 1:

Input: cost = [10,15,20]
Output: 15
Explanation: You will start at index 1.
- Pay 15 and climb two steps to reach the top.
The total cost is 15.
Example 2:

Input: cost = [1,100,1,1,1,100,1,1,100,1]
Output: 6
Explanation: You will start at index 0.
- Pay 1 and climb two steps to reach index 2.
- Pay 1 and climb two steps to reach index 4.
- Pay 1 and climb two steps to reach index 6.
- Pay 1 and climb one step to reach index 7.
- Pay 1 and climb two steps to reach index 9.
- Pay 1 and climb one step to reach the top.
The total cost is 6.
 

Constraints:

2 <= cost.length <= 1000
0 <= cost[i] <= 999",Easy,,DP,,1.2M,1.8M,65.70%,189,,X,,,,
323,Climbing Stairs,https://leetcode.com/problems/climbing-stairs/,"You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?","Example 1:

Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
Example 2:

Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
",Easy,1D DP,DP,,3.3M,6.2M,52.90%,289,X,X,X,X,X,X
324,House Robber,https://leetcode.com/problems/house-robber/,,,Medium,1D DP,DP,,,,,,X,X,X,X,,X
325,House Robber II,https://leetcode.com/problems/house-robber-ii/,,,Medium,1D DP,DP,,,,,,X,X,X,,,X
326,Decode Ways,https://leetcode.com/problems/decode-ways/,"A message containing letters from A-Z can be encoded into numbers using the following mapping:

'A' -> ""1""
'B' -> ""2""
...
'Z' -> ""26""
To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, ""11106"" can be mapped into:

""AAJF"" with the grouping (1 1 10 6)
""KJF"" with the grouping (11 10 6)
Note that the grouping (1 11 06) is invalid because ""06"" cannot be mapped into 'F' since ""6"" is different from ""06"".

Given a string s containing only digits, return the number of ways to decode it.

The test cases are generated so that the answer fits in a 32-bit integer.","Example 1:

Input: s = ""12""
Output: 2
Explanation: ""12"" could be decoded as ""AB"" (1 2) or ""L"" (12).
Example 2:

Input: s = ""226""
Output: 3
Explanation: ""226"" could be decoded as ""BZ"" (2 26), ""VF"" (22 6), or ""BBF"" (2 2 6).
Example 3:

Input: s = ""06""
Output: 0
Explanation: ""06"" cannot be mapped to ""F"" because of the leading zero (""6"" is different from ""06"").
 

Constraints:

1 <= s.length <= 100
s contains only digits and may contain leading zero(s).",Medium,1D DP,DP,,1.3M,3.6M,34.90%,210,X,X,X,X,,X
327,Unique Paths,https://leetcode.com/problems/unique-paths/,"There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.

The test cases are generated so that the answer will be less than or equal to 2 * 109.

","Example 1:


Input: m = 3, n = 7
Output: 28
Example 2:

Input: m = 3, n = 2
Output: 3
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Down -> Down
2. Down -> Down -> Right
3. Down -> Right -> Down
",Medium,2D DP,DP,,1.8M,2.8M,64.40%,126,X,X,,X,X,X
328,Unique Paths II,https://leetcode.com/problems/unique-paths-ii/,"You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.

Return the number of possible unique paths that the robot can take to reach the bottom-right corner.

The testcases are generated so that the answer will be less than or equal to 2 * 109.","Example 1:


Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
Output: 2
Explanation: There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right
Example 2:


Input: obstacleGrid = [[0,1],[0,0]]
Output: 1
 

Constraints:

m == obstacleGrid.length
n == obstacleGrid[i].length
1 <= m, n <= 100
obstacleGrid[i][j] is 0 or 1.",Medium,2D DP,DP,,931.8K,2.2M,41.60%,93,,,,,,
329,Target Sum,https://leetcode.com/problems/target-sum/,"You are given an integer array nums and an integer target.

You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.

For example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression ""+2-1"".
Return the number of different expressions that you can build, which evaluates to target.","Example 1:

Input: nums = [1,1,1,1,1], target = 3
Output: 5
Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3.
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
Example 2:

Input: nums = [1], target = 1
Output: 1
 

Constraints:

1 <= nums.length <= 20
0 <= nums[i] <= 1000
0 <= sum(nums[i]) <= 1000
-1000 <= target <= 1000",Medium,2D DP,DP,,593.9K,1.3M,46.90%,50,,X,,,,X
330,Number of Dice Rolls w/Target Sum,https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/,"You have n dice, and each dice has k faces numbered from 1 to k.

Given three integers n, k, and target, return the number of possible ways (out of the kn total ways) to roll the dice, so the sum of the face-up numbers equals target. Since the answer may be too large, return it modulo 109 + 7.","Example 1:

Input: n = 1, k = 6, target = 3
Output: 1
Explanation: You throw one die with 6 faces.
There is only one way to get a sum of 3.
Example 2:

Input: n = 2, k = 6, target = 7
Output: 6
Explanation: You throw two dice, each with 6 faces.
There are 6 ways to get a sum of 7: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1.
Example 3:

Input: n = 30, k = 30, target = 500
Output: 222616187
Explanation: The answer must be returned modulo 109 + 7.
 

Constraints:

1 <= n, k <= 30
1 <= target <= 1000",Medium,,DP,,287.4K,472.5K,60.80%,115,,,,,,
331,Maximum Length of Repeated Subarray,https://leetcode.com/problems/maximum-length-of-repeated-subarray/,"Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.","Example 1:

Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
Output: 3
Explanation: The repeated subarray with maximum length is [3,2,1].
Example 2:

Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
Output: 5
Explanation: The repeated subarray with maximum length is [0,0,0,0,0].
 

Constraints:

1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 100",Medium,,DP,,299.2K,587.2K,51.00%,19,,,,,,
332,Longest Common Subsequence,https://leetcode.com/problems/longest-common-subsequence/,"Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, ""ace"" is a subsequence of ""abcde"".
A common subsequence of two strings is a subsequence that is common to both strings.

","Example 1:

Input: text1 = ""abcde"", text2 = ""ace"" 
Output: 3  
Explanation: The longest common subsequence is ""ace"" and its length is 3.
Example 2:

Input: text1 = ""abc"", text2 = ""abc""
Output: 3
Explanation: The longest common subsequence is ""abc"" and its length is 3.
Example 3:

Input: text1 = ""abc"", text2 = ""def""
Output: 0
Explanation: There is no such common subsequence, so the result is 0.
 

Constraints:

1 <= text1.length, text2.length <= 1000
text1 and text2 consist of only lowercase English characters.",Medium,2D DP,DP,,1.1M,1.9M,57.80%,138,X,X,,,,
333,Edit Distance,https://leetcode.com/problems/edit-distance/,"Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.

You have the following three operations permitted on a word:

Insert a character
Delete a character
Replace a character","Example 1:

Input: word1 = ""horse"", word2 = ""ros""
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')
Example 2:

Input: word1 = ""intention"", word2 = ""execution""
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
 

Constraints:

0 <= word1.length, word2.length <= 500
word1 and word2 consist of lowercase English letters.",Hard,2D DP,"DP, String",,857.3K,1.5M,56.50%,75,,X,,,,
334,Longest Palindromic Subsequence,https://leetcode.com/problems/longest-palindromic-subsequence/,"Given a string s, find the longest palindromic subsequence's length in s.

A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.","Example 1:

Input: s = ""bbbab""
Output: 4
Explanation: One possible longest palindromic subsequence is ""bbbb"".
Example 2:

Input: s = ""cbbd""
Output: 2
Explanation: One possible longest palindromic subsequence is ""bb"".
 

Constraints:

1 <= s.length <= 1000
s consists only of lowercase English letters.",Medium,2D DP,DP,,484.6K,773.8K,62.60%,67,,,,,,X
335,Valid Palindrome 3,https://leetcode.com/problems/valid-palindrome-iii/solution/,,,Hard,Two Pointers,DP,,,,,,,,,,,
336,Longest Increasing Subsequence,https://leetcode.com/problems/longest-increasing-subsequence/,"Given an integer array nums, return the length of the longest strictly increasing subsequence
.Follow up: Can you come up with an algorithm that runs in O(n log(n)) time complexity?

","Example 1:

Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
Example 2:

Input: nums = [0,1,0,3,2,3]
Output: 4
Example 3:

Input: nums = [7,7,7,7,7,7,7]
Output: 1
 

Constraints:

1 <= nums.length <= 2500
-104 <= nums[i] <= 104
",Medium,1D DP,DP,,1.7M,3M,55.40%,150,X,X,X,X,X,X
337,Number of Longest Increasing Subsequence,https://leetcode.com/problems/number-of-longest-increasing-subsequence/,"Given an integer array nums, return the number of longest increasing subsequences.

Notice that the sequence has to be strictly increasing.","Example 1:

Input: nums = [1,3,5,4,7]
Output: 2
Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].
Example 2:

Input: nums = [2,2,2,2,2]
Output: 5
Explanation: The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.
 

Constraints:

1 <= nums.length <= 2000
-106 <= nums[i] <= 106",Medium,,DP,,227.9K,474.5K,48.00%,42,,,,,,X
338,Longest Increasing Path in Matrix,https://leetcode.com/problems/longest-increasing-path-in-a-matrix/,"Given an m x n integers matrix, return the length of the longest increasing path in matrix.

From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).

","Example 1:


Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]
Output: 4
Explanation: The longest increasing path is [1, 2, 6, 9].
Example 2:


Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]
Output: 4
Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.
Example 3:

Input: matrix = [[1]]
Output: 1

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 200
0 <= matrix[i][j] <= 231 - 1",Hard,2D DP,"DP, Array, DFS, BFS, Graph, Topological Sort, Memoization, Matrix",,524.3K,977.3K,53.70%,36,,X,,,,
339,Jump Game,https://leetcode.com/problems/jump-game/,"You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.

Return true if you can reach the last index, or false otherwise.","Example 1:

Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
Example 2:

Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.
 
",Medium,,DP,,1.9M,4.9M,38.50%,171,X,X,X,X,,X
340,Jump Game 2,https://leetcode.com/problems/jump-game-ii/,"You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].

Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:

0 <= j <= nums[i] and
i + j < n
Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].

","Example 1:

Input: nums = [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.
Example 2:

Input: nums = [2,3,0,1,4]
Output: 2
 

Constraints:

1 <= nums.length <= 104
0 <= nums[i] <= 1000
It's guaranteed that you can reach nums[n - 1].",Medium,,DP,,1.2M,3.1M,40.50%,131,,X,,,,
341,Word Break,https://leetcode.com/problems/word-break/,"Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.

Note that the same word in the dictionary may be reused multiple times in the segmentation.","Example 1:

Input: s = ""leetcode"", wordDict = [""leet"",""code""]
Output: true
Explanation: Return true because ""leetcode"" can be segmented as ""leet code"".
Example 2:

Input: s = ""applepenapple"", wordDict = [""apple"",""pen""]
Output: true
Explanation: Return true because ""applepenapple"" can be segmented as ""apple pen apple"".
Note that you are allowed to reuse a dictionary word.
Example 3:

Input: s = ""catsandog"", wordDict = [""cats"",""dog"",""sand"",""and"",""cat""]
Output: false
 

Constraints:

1 <= s.length <= 300
1 <= wordDict.length <= 1000
1 <= wordDict[i].length <= 20
s and wordDict[i] consist of only lowercase English letters.
All the strings of wordDict are unique.",Medium,1D DP,DP,,1.7M,3.6M,46.80%,126,X,X,X,X,X,X
342,Word Break 2,https://leetcode.com/problems/word-break-ii/,"Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.

Note that the same word in the dictionary may be reused multiple times in the segmentation.

","Example 1:

Input: s = ""catsanddog"", wordDict = [""cat"",""cats"",""and"",""sand"",""dog""]
Output: [""cats and dog"",""cat sand dog""]
Example 2:

Input: s = ""pineapplepenapple"", wordDict = [""apple"",""pen"",""applepen"",""pine"",""pineapple""]
Output: [""pine apple pen apple"",""pineapple pen apple"",""pine applepen apple""]
Explanation: Note that you are allowed to reuse a dictionary word.
Example 3:

Input: s = ""catsandog"", wordDict = [""cats"",""dog"",""sand"",""and"",""cat""]
Output: []
 

Constraints:

1 <= s.length <= 20
1 <= wordDict.length <= 1000
1 <= wordDict[i].length <= 10
s and wordDict[i] consist of only lowercase English letters.
All the strings of wordDict are unique.
Input is generated in a way that the length of the answer doesn't exceed 105.",Hard,,DP,,584.4K,1.2M,48.20%,41,,,,,,
343,Concatenated Words,https://leetcode.com/problems/concatenated-words/,"Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.

A concatenated word is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct) in the given array.

","xample 1:

Input: words = [""cat"",""cats"",""catsdogcats"",""dog"",""dogcatsdog"",""hippopotamuses"",""rat"",""ratcatdogcat""]
Output: [""catsdogcats"",""dogcatsdog"",""ratcatdogcat""]
Explanation: ""catsdogcats"" can be concatenated by ""cats"", ""dog"" and ""cats""; 
""dogcatsdog"" can be concatenated by ""dog"", ""cats"" and ""dog""; 
""ratcatdogcat"" can be concatenated by ""rat"", ""cat"", ""dog"" and ""cat"".
Example 2:

Input: words = [""cat"",""dog"",""catdog""]
Output: [""catdog""]
 

Constraints:

1 <= words.length <= 104
1 <= words[i].length <= 30
words[i] consists of only lowercase English letters.
All the strings of words are unique.
1 <= sum(words[i].length) <= 105",Hard,,DP,,223.8K,452.8K,49.40%,62,,,,,,X
344,Interleaving String,https://leetcode.com/problems/interleaving-string/,"Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.

An interleaving of two strings s and t is a configuration where s and t are divided into n and m 
substrings
 respectively, such that:

s = s1 + s2 + ... + sn
t = t1 + t2 + ... + tm
|n - m| <= 1
The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...
Note: a + b is the concatenation of strings a and b.

Follow up: Could you solve it using only O(s2.length) additional memory space?

","Example 1:


Input: s1 = ""aabcc"", s2 = ""dbbca"", s3 = ""aadbbcbcac""
Output: true
Explanation: One way to obtain s3 is:
Split s1 into s1 = ""aa"" + ""bc"" + ""c"", and s2 into s2 = ""dbbc"" + ""a"".
Interleaving the two splits, we get ""aa"" + ""dbbc"" + ""bc"" + ""a"" + ""c"" = ""aadbbcbcac"".
Since s3 can be obtained by interleaving s1 and s2, we return true.
Example 2:

Input: s1 = ""aabcc"", s2 = ""dbbca"", s3 = ""aadbbbaccc""
Output: false
Explanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.
Example 3:

Input: s1 = """", s2 = """", s3 = """"
Output: true
 

Constraints:

0 <= s1.length, s2.length <= 100
0 <= s3.length <= 200
s1, s2, and s3 consist of lowercase English letters.",Medium,,DP,,521.9K,1.3M,40.00%,87,,X,,,,
345,Paint House,https://leetcode.com/problems/paint-house/,,,Medium,,DP,,,,,,,,,,,
346,Maximal Square,https://leetcode.com/problems/maximal-square/,"Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.

","Example 1:


Input: matrix = [[""1"",""0"",""1"",""0"",""0""],[""1"",""0"",""1"",""1"",""1""],[""1"",""1"",""1"",""1"",""1""],[""1"",""0"",""0"",""1"",""0""]]
Output: 4
Example 2:


Input: matrix = [[""0"",""1""],[""1"",""0""]]
Output: 1
Example 3:

Input: matrix = [[""0""]]
Output: 0
 

Constraints:

m == matrix.length
n == matrix[i].length
1 <= m, n <= 300
matrix[i][j] is '0' or '1'.",Medium,,DP,,682.9K,1.5M,46.60%,33,,,,X,,
347,Distinct Subsequences,https://leetcode.com/problems/distinct-subsequences/,"Given two strings s and t, return the number of distinct subsequences of s which equals t.

The test cases are generated so that the answer fits on a 32-bit signed integer.","Example 1:

Input: s = ""rabbbit"", t = ""rabbit""
Output: 3
Explanation:
As shown below, there are 3 ways you can generate ""rabbit"" from s.
rabbbit
rabbbit
rabbbit
Example 2:

Input: s = ""babgbag"", t = ""bag""
Output: 5
Explanation:
As shown below, there are 5 ways you can generate ""bag"" from s.
babgbag
babgbag
babgbag
babgbag
babgbag
 

Constraints:

1 <= s.length, t.length <= 1000
s and t consist of English letters.",Hard,2D DP,DP,,397.8K,844.8K,47.10%,81,,X,,,,
348,Burst Balloons,https://leetcode.com/problems/burst-balloons/,"You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.

If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.

Return the maximum coins you can collect by bursting the balloons wisely.

","Example 1:

Input: nums = [3,1,5,8]
Output: 167
Explanation:
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
Example 2:

Input: nums = [1,5]
Output: 10",Hard,2D DP,"DP, Array",,281.6K,478.6K,58.58%,32,,X,,,X,
349,Perfect Squares,https://leetcode.com/problems/perfect-squares/,"Given an integer n, return the least number of perfect square numbers that sum to n.

A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.","Example 1:

Input: n = 12
Output: 3
Explanation: 12 = 4 + 4 + 4.
Example 2:

Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.",Medium,Math,"DP, Math, BFS",367,850.7K,1.6M,54.80%,96,,,,,,
350,Minimum Cost Tree from Leaf Values,https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/,"Given an array arr of positive integers, consider all binary trees such that:

Each node has either 0 or 2 children;
The values of arr correspond to the values of each leaf in an in-order traversal of the tree.
The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.
Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node. It is guaranteed this sum fits into a 32-bit integer.

A node is a leaf if and only if it has zero children.

","Example 1:


Input: arr = [6,2,4]
Output: 32
Explanation: There are two possible trees shown.
The first has a non-leaf node sum 36, and the second has non-leaf node sum 32.
Example 2:


Input: arr = [4,11]
Output: 44
 

Constraints:

2 <= arr.length <= 40
1 <= arr[i] <= 15
It is guaranteed that the answer fits into a 32-bit signed integer (i.e., it is less than 231).",Medium,,DP,,98.7K,145.6K,67.80%,19,,,,,,
351,Unique BST's,https://leetcode.com/problems/unique-binary-search-trees/,"Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.","Example 1:


Input: n = 3
Output: 5
Example 2:

Input: n = 1
Output: 1
 

Constraints:

1 <= n <= 19",Medium,,DP,,660.2K,1.1M,61.10%,33,,,,,,
352,Triangle,https://leetcode.com/problems/triangle/,"Given a triangle array, return the minimum path sum from top to bottom.

For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.

Follow up: Could you do this using only O(n) extra space, where n is the total number of rows in the triangle?
","Example 1:

Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
Output: 11
Explanation: The triangle looks like:
   2
  3 4
 6 5 7
4 1 8 3
The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).
Example 2:

Input: triangle = [[-10]]
Output: -10
 

Constraints:

1 <= triangle.length <= 200
triangle[0].length == 1
triangle[i].length == triangle[i - 1].length + 1
-104 <= triangle[i][j] <= 104
",Medium,,DP,,755.9K,1.3M,56.70%,82,,,,,,
353,All Possible Full Binary Trees,https://leetcode.com/problems/all-possible-full-binary-trees/,"Given an integer n, return a list of all possible full binary trees with n nodes. Each node of each tree in the answer must have Node.val == 0.

Each element of the answer is the root node of one possible tree. You may return the final list of trees in any order.

A full binary tree is a binary tree where each node has exactly 0 or 2 children.","Example 1:


Input: n = 7
Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]
Example 2:

Input: n = 3
Output: [[0,0,0]]
 

Constraints:

1 <= n <= 20",Medium,,DP,,182K,220.1K,82.70%,53,,,,,,
354,Minimum Cost for Tickets,https://leetcode.com/problems/minimum-cost-for-tickets/,"You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.

Train tickets are sold in three different ways:

a 1-day pass is sold for costs[0] dollars,
a 7-day pass is sold for costs[1] dollars, and
a 30-day pass is sold for costs[2] dollars.
The passes allow that many days of consecutive travel.

For example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.
Return the minimum number of dollars you need to travel every day in the given list of days.","Example 1:

Input: days = [1,4,6,7,8,20], costs = [2,7,15]
Output: 11
Explanation: For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.
On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.
On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.
In total, you spent $11 and covered all the days of your travel.
Example 2:

Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]
Output: 17
Explanation: For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.
On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.
In total, you spent $17 and covered all the days of your travel.
 

Constraints:

1 <= days.length <= 365
1 <= days[i] <= 365
days is in strictly increasing order.
costs.length == 3
1 <= costs[i] <= 1000",Medium,,DP,,289.8K,444.1K,65.30%,43,,,,,,
355,"Number of Ways to Rearrange Sticks 
with K Sticks Visible",https://leetcode.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/,"There are n uniquely-sized sticks whose lengths are integers from 1 to n. You want to arrange the sticks such that exactly k sticks are visible from the left. A stick is visible from the left if there are no longer sticks to the left of it.

For example, if the sticks are arranged [1,3,2,5,4], then the sticks with lengths 1, 3, and 5 are visible from the left.
Given n and k, return the number of such arrangements. Since the answer may be large, return it modulo 109 + 7.","Example 1:

Input: n = 3, k = 2
Output: 3
Explanation: [1,3,2], [2,3,1], and [2,1,3] are the only arrangements such that exactly 2 sticks are visible.
The visible sticks are underlined.
Example 2:

Input: n = 5, k = 5
Output: 1
Explanation: [1,2,3,4,5] is the only arrangement such that all 5 sticks are visible.
The visible sticks are underlined.
Example 3:

Input: n = 20, k = 11
Output: 647427950
Explanation: There are 647427950 (mod 109 + 7) ways to rearrange the sticks such that exactly 11 sticks are visible.
",Hard,,"DP, Math, Combinatorics",,14.1K,24.8K,57.00%,4,,,,,,
356,Stickers to Spell Word,https://leetcode.com/problems/stickers-to-spell-word/,"We are given n different types of stickers. Each sticker has a lowercase English word on it.

You would like to spell out the given string target by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker.

Return the minimum number of stickers that you need to spell out target. If the task is impossible, return -1.

Note: In all test cases, all words were chosen randomly from the 1000 most common US English words, and target was chosen as a concatenation of two random words.","Example 1:

Input: stickers = [""with"",""example"",""science""], target = ""thehat""
Output: 3
Explanation:
We can use 2 ""with"" stickers, and 1 ""example"" sticker.
After cutting and rearrange the letters of those stickers, we can form the target ""thehat"".
Also, this is the minimum number of stickers necessary to form the target string.
Example 2:

Input: stickers = [""notice"",""possible""], target = ""basicbasic""
Output: -1
Explanation:
We cannot form the target ""basicbasic"" from cutting letters from the given stickers.
 

Constraints:

n == stickers.length
1 <= n <= 50
1 <= stickers[i].length <= 10
1 <= target.length <= 15
stickers[i] and target consist of lowercase English letters.",Hard,,DP,,68.5K,142.7K,48.70%,12,,,,,,
357,Minimum Number of Days to Eat N Oranges,https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/,"There are n oranges in the kitchen and you decided to eat some of these oranges every day as follows:

Eat one orange.
If the number of remaining oranges n is divisible by 2 then you can eat n / 2 oranges.
If the number of remaining oranges n is divisible by 3 then you can eat 2 * (n / 3) oranges.
You can only choose one of the actions per day.

Given the integer n, return the minimum number of days to eat n oranges.","Example 1:

Input: n = 10
Output: 4
Explanation: You have 10 oranges.
Day 1: Eat 1 orange,  10 - 1 = 9.  
Day 2: Eat 6 oranges, 9 - 2*(9/3) = 9 - 6 = 3. (Since 9 is divisible by 3)
Day 3: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. 
Day 4: Eat the last orange  1 - 1  = 0.
You need at least 4 days to eat the 10 oranges.
Example 2:

Input: n = 6
Output: 3
Explanation: You have 6 oranges.
Day 1: Eat 3 oranges, 6 - 6/2 = 6 - 3 = 3. (Since 6 is divisible by 2).
Day 2: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. (Since 3 is divisible by 3)
Day 3: Eat the last orange  1 - 1  = 0.
You need at least 3 days to eat the 6 oranges.
  ",Hard,,DP,,35.4K,100.3K,35.30%,10,,,,,,
358,Pascal's Triangle,https://leetcode.com/problems/pascals-triangle/,"Given an integer numRows, return the first numRows of Pascal's triangle.

In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:","Example 1:

Input: numRows = 5
Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
Example 2:

Input: numRows = 1
Output: [[1]]",Easy,,DP,,1.7M,2.2M,74.40%,118,,,,,,
359,Stone Game,https://leetcode.com/problems/stone-game/,"Alice and Bob play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].

The objective of the game is to end with the most stones. The total number of stones across all the piles is odd, so there are no ties.

Alice and Bob take turns, with Alice starting first. Each turn, a player takes the entire pile of stones either from the beginning or from the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins.

Assuming Alice and Bob play optimally, return true if Alice wins the game, or false if Bob wins.

","Example 1:

Input: piles = [5,3,4,5]
Output: true
Explanation: 
Alice starts first, and can only take the first 5 or the last 5.
Say she takes the first 5, so that the row becomes [3, 4, 5].
If Bob takes 3, then the board is [4, 5], and Alice takes 5 to win with 10 points.
If Bob takes the last 5, then the board is [3, 4], and Alice takes 4 to win with 9 points.
This demonstrated that taking the first 5 was a winning move for Alice, so we return true.
Example 2:

Input: piles = [3,7,2,3]
Output: true
 

Constraints:

2 <= piles.length <= 500
piles.length is even.
1 <= piles[i] <= 500
sum(piles[i]) is odd.",Medium,,DP,,233.9K,331.5K,70.50%,86,,,,,,
360,Integer Break,https://leetcode.com/problems/integer-break/,"Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.

Return the maximum product you can get.","Example 1:

Input: n = 2
Output: 1
Explanation: 2 = 1 + 1, 1 × 1 = 1.
Example 2:

Input: n = 10
Output: 36
Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.
",Medium,,"DP, Math",,357.4K,592.2K,60.40%,65,,,,,,
361,Delete and Earn,https://leetcode.com/problems/delete-and-earn/,"You are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times:

Pick any nums[i] and delete it to earn nums[i] points. Afterwards, you must delete every element equal to nums[i] - 1 and every element equal to nums[i] + 1.
Return the maximum number of points you can earn by applying the above operation some number of times.

 ","Example 1:

Input: nums = [3,4,2]
Output: 6
Explanation: You can perform the following operations:
- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2].
- Delete 2 to earn 2 points. nums = [].
You earn a total of 6 points.
Example 2:

Input: nums = [2,2,3,3,3,4]
Output: 9
Explanation: You can perform the following operations:
- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [3,3].
- Delete a 3 again to earn 3 points. nums = [3].
- Delete a 3 once more to earn 3 points. nums = [].
You earn a total of 9 points.",Medium,,DP,,338.6K,599.3K,56.50%,50,,,,,,
,,,,,,,,,,,,,,,,,,
363,Happy Number,https://leetcode.com/problems/happy-number/,"Write an algorithm to determine if a number n is happy.

A happy number is a number defined by the following process:

Starting with any positive integer, replace the number by the sum of the squares of its digits.
Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
Those numbers for which this process ends in 1 are happy.
Return true if n is a happy number, and false if not.","Example 1:

Input: n = 19
Output: true
Explanation:
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
Example 2:

Input: n = 2
Output: false",Easy,Math,Math,,1.5M,2.6M,56.20%,153,,X,,,,
364,Plus One,https://leetcode.com/problems/plus-one/,"You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.

Increment the large integer by one and return the resulting array of digits.","Example 1:

Input: digits = [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
Incrementing by one gives 123 + 1 = 124.
Thus, the result should be [1,2,4].
Example 2:

Input: digits = [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.
Incrementing by one gives 4321 + 1 = 4322.
Thus, the result should be [4,3,2,2].
Example 3:

Input: digits = [9]
Output: [1,0]
Explanation: The array represents the integer 9.
Incrementing by one gives 9 + 1 = 10.
Thus, the result should be [1,0].
 

Constraints:

1 <= digits.length <= 100
0 <= digits[i] <= 9
digits does not contain any leading 0's.",Easy,Math,Math,,2.2M,5M,45.40%,204,,X,,,,
365,Multiply Strings,https://leetcode.com/problems/multiply-strings/,"Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.

Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.","Example 1:

Input: num1 = ""2"", num2 = ""3""
Output: ""6""
Example 2:

Input: num1 = ""123"", num2 = ""456""
Output: ""56088""
 

Constraints:

1 <= num1.length, num2.length <= 200
num1 and num2 consist of digits only.
Both num1 and num2 do not contain any leading zero, except the number 0 itself.",Medium,Math,Math,,798.8K,2M,40.50%,99,,X,,,,
366,Detect Squares,https://leetcode.com/problems/detect-squares/,"You are given a stream of points on the X-Y plane. Design an algorithm that:

Adds new points from the stream into a data structure. Duplicate points are allowed and should be treated as different points.
Given a query point, counts the number of ways to choose three points from the data structure such that the three points and the query point form an axis-aligned square with positive area.
An axis-aligned square is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.

Implement the DetectSquares class:

DetectSquares() Initializes the object with an empty data structure.
void add(int[] point) Adds a new point point = [x, y] to the data structure.
int count(int[] point) Counts the number of ways to form axis-aligned squares with point point = [x, y] as described above.","Example 1:


Input
[""DetectSquares"", ""add"", ""add"", ""add"", ""count"", ""count"", ""add"", ""count""]
[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]
Output
[null, null, null, null, 1, 0, null, 2]

Explanation
DetectSquares detectSquares = new DetectSquares();
detectSquares.add([3, 10]);
detectSquares.add([11, 2]);
detectSquares.add([3, 2]);
detectSquares.count([11, 10]); // return 1. You can choose:
                               //   - The first, second, and third points
detectSquares.count([14, 8]);  // return 0. The query point cannot form a square with any points in the data structure.
detectSquares.add([11, 2]);    // Adding duplicate points is allowed.
detectSquares.count([11, 10]); // return 2. You can choose:
                               //   - The first, second, and third points
                               //   - The first, third, and fourth points
 

Constraints:

point.length == 2
0 <= x, y <= 1000
At most 3000 calls in total will be made to add and count.",Medium,Math,Math,,64.7K,127.2K,50.90%,9,,X,,,,
367,Count Primes,https://leetcode.com/problems/count-primes/,"Given an integer n, return the number of prime numbers that are strictly less than n.

","Example 1:

Input: n = 10
Output: 4
Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
Example 2:

Input: n = 0
Output: 0
Example 3:

Input: n = 1
Output: 0",Medium,Math,"Math, Array, Enumeration, Math Theory",349,862.8K,2.6M,33.60%,65,,,,,X,
368,Power of Three,https://leetcode.com/problems/power-of-three/,"Given an integer n, return true if it is a power of three. Otherwise, return false.

An integer n is a power of three, if there exists an integer x such that n == 3x.

Follow up: Could you solve it without loops/recursion?

 ","Example 1:

Input: n = 27
Output: true
Explanation: 27 = 33
Example 2:

Input: n = 0
Output: false
Explanation: There is no x where 3x = 0.
Example 3:

Input: n = -1
Output: false
Explanation: There is no x where 3x = (-1).
",Easy,Math,Math,,833.9K,1.8M,46.60%,46,,,,,X,
369,Excel Sheet Column Number,https://leetcode.com/problems/excel-sheet-column-number/,"Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.

For example:

A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...
","Example 1:

Input: columnTitle = ""A""
Output: 1
Example 2:

Input: columnTitle = ""AB""
Output: 28
Example 3:

Input: columnTitle = ""ZY""
Output: 701
 

Constraints:

1 <= columnTitle.length <= 7
columnTitle consists only of uppercase English letters.
columnTitle is in the range [""A"", ""FXSHRXW""].",Easy,Math,Math,,686.2K,1.1M,63.80%,21,,,,,X,
370,"Pow(x, n)",https://leetcode.com/problems/powx-n/,"Implement pow(x, n), which calculates x raised to the power n (i.e., xn).","Example 1:

Input: x = 2.00000, n = 10
Output: 1024.00000
Example 2:

Input: x = 2.10000, n = 3
Output: 9.26100
Example 3:

Input: x = 2.00000, n = -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
 

Constraints:

-100.0 < x < 100.0
-231 <= n <= 231-1
n is an integer.
Either x is not zero or n > 0.
-104 <= xn <= 104",Medium,Math,Math,,,,,,,X,,X,X,
371,Task Scheduler,https://leetcode.com/problems/task-scheduler/,"You are given an array of CPU tasks, each represented by letters A to Z, and a cooling time, n. Each cycle or interval allows the completion of one task. Tasks can be completed in any order, but there's a constraint: identical tasks must be separated by at least n intervals due to cooling time.

​Return the minimum number of intervals required to complete all tasks.","Example 1:

Input: tasks = [""A"",""A"",""A"",""B"",""B"",""B""], n = 2

Output: 8

Explanation: A possible sequence is: A -> B -> idle -> A -> B -> idle -> A -> B.

After completing task A, you must wait two cycles before doing A again. The same applies to task B. In the 3rd interval, neither A nor B can be done, so you idle. By the 4th cycle, you can do A again as 2 intervals have passed.

Example 2:

Input: tasks = [""A"",""C"",""A"",""B"",""D"",""B""], n = 1

Output: 6

Explanation: A possible sequence is: A -> B -> C -> D -> A -> B.

With a cooling interval of 1, you can repeat a task after just one other task.

Example 3:

Input: tasks = [""A"",""A"",""A"", ""B"",""B"",""B""], n = 3

Output: 10

Explanation: A possible sequence is: A -> B -> idle -> idle -> A -> B -> idle -> idle -> A -> B.

There are only two types of tasks, A and B, which need to be separated by 3 intervals. This leads to idling twice between repetitions of these tasks.

 

Constraints:

1 <= tasks.length <= 104
tasks[i] is an uppercase English letter.
0 <= n <= 100",Medium,Math,Math,,629.1K,1M,59.90%,125,,X,,X,X,X
372,Max Points on a Line,https://leetcode.com/problems/max-points-on-a-line/,"Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.

","Example 1:


Input: points = [[1,1],[2,2],[3,3]]
Output: 3
Example 2:


Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
Output: 4
 

Constraints:

1 <= points.length <= 300
points[i].length == 2
-104 <= xi, yi <= 104
All the points are unique.",Hard,Math,Math,,392.3K,1.5M,26.80%,159,,,,,X,
373,Integer to English Words,https://leetcode.com/problems/integer-to-english-words/,"Convert a non-negative integer num to its English words representation.

","Example 1:

Input: num = 123
Output: ""One Hundred Twenty Three""
Example 2:

Input: num = 12345
Output: ""Twelve Thousand Three Hundred Forty Five""
Example 3:

Input: num = 1234567
Output: ""One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven""
 ",Hard,Math,Math,,380.8K,1.2M,30.60%,44,,,,,,
,,,,,,,,,,,,,,,,,,
375,Add Binary,https://leetcode.com/problems/add-binary/,"Given two binary strings a and b, return their sum as a binary string.

","Example 1:

Input: a = ""11"", b = ""1""
Output: ""100""
Example 2:

Input: a = ""1010"", b = ""1011""
Output: ""10101""
 

Constraints:

1 <= a.length, b.length <= 104
a and b consist only of '0' or '1' characters.
Each string does not contain leading zeros except for the zero itself.",Easy,Bit Manipulation,"Binary, Bit Manipulation",,1.5M,2.7M,53.60%,137,,,,X,,
376,Number of 1 Bits,https://leetcode.com/problems/number-of-1-bits/,Write a function that takes the binary representation of a positive integer and returns the number of set bits it has (also known as the Hamming weight).,"Example 1:

Input: n = 11

Output: 3

Explanation:

The input binary string 1011 has a total of three set bits.

Example 2:

Input: n = 128

Output: 1

Explanation:

The input binary string 10000000 has a total of one set bit.

Example 3:

Input: n = 2147483645

Output: 30

Explanation:

The input binary string 1111111111111111111111111111101 has a total of thirty set bits.",Easy,Bit Manipulation,Binary,,1.5M,2.1M,71.20%,153,,X,,X,X,
377,Counting Bits,https://leetcode.com/problems/counting-bits/,"Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.

Follow up:

It is very easy to come up with a solution with a runtime of O(n log n). Can you do it in linear time O(n) and possibly in a single pass?
Can you do it without using any built-in function 
","Example 1:

Input: n = 2
Output: [0,1,1]
Explanation:
0 --> 0
1 --> 1
2 --> 10
Example 2:

Input: n = 5
Output: [0,1,1,2,1,2]
Explanation:
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
 

Constraints:

0 <= n <= 105
",Easy,Bit Manipulation,Binary,,1.1M,1.4M,78.30%,73,,X,,X,,X
378,Reverse Bits,https://leetcode.com/problems/reverse-bits/,"Reverse bits of a given 32 bits unsigned integer.

Note:

Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.

Follow up: If this function is called many times, how would you optimize it?



","Example 1:

Input: n = 00000010100101000001111010011100
Output:    964176192 (00111001011110000010100101000000)
Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.
Example 2:

Input: n = 11111111111111111111111111111101
Output:   3221225471 (10111111111111111111111111111111)
Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.
 

Constraints:

The input must be a binary string of length 32",Easy,Bit Manipulation,Binary,,797.6K,1.4M,58.70%,69,,X,,X,,
379,Reverse Integer,https://leetcode.com/problems/reverse-integer/,"Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.

Assume the environment does not allow you to store 64-bit integers (signed or unsigned).

Follow up: If this function is called many times, how would you optimize it?
","Example 1:

Input: x = 123
Output: 321
Example 2:

Input: x = -123
Output: -321
Example 3:

Input: x = 120
Output: 21",Medium,Bit Manipulation,Binary,,3.2M,11.2M,28.60%,339,,X,,X,,
380,Sum of Two Integers,https://leetcode.com/problems/sum-of-two-integers/,"Given two integers a and b, return the sum of the two integers without using the operators + and -.

","Example 1:

Input: a = 1, b = 2
Output: 3
Example 2:

Input: a = 2, b = 3
Output: 5",Medium,Bit Manipulation,Binary,,480.1K,924.5K,51.90%,64,,X,,,,
381,Divide Two Integers,https://leetcode.com/problems/divide-two-integers/,"Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.

The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.

Return the quotient after dividing dividend by divisor.

Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.","Example 1:

Input: dividend = 10, divisor = 3
Output: 3
Explanation: 10/3 = 3.33333.. which is truncated to 3.
Example 2:

Input: dividend = 7, divisor = -3
Output: -2
Explanation: 7/-3 = -2.33333.. which is truncated to -2.
 

Constraints:

-231 <= dividend, divisor <= 231 - 1
divisor != 0",Medium,Bit Manipulation,Binary,,744.8K,4.3M,17.50%,206,,,,,,
382,Maximum XOR of Two Numbers in an Array,https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/,"Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n.

","Example 1:

Input: nums = [3,10,5,25,2,8]
Output: 28
Explanation: The maximum result is 5 XOR 25 = 28.
Example 2:

Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70]
Output: 127
",Medium,Bit Manipulation,Binary,,161K,302.5K,53.20%,46,,,,,,X
383,LFU Cache,https://leetcode.com/problems/lfu-cache/description/,"Design and implement a data structure for a Least Frequently Used (LFU) cache.

Implement the LFUCache class:

LFUCache(int capacity) Initializes the object with the capacity of the data structure.
int get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns -1.
void put(int key, int value) Update the value of the key if present, or inserts the key if not already present. When the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used key would be invalidated.
To determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key.

When a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented either a get or put operation is called on it.

The functions get and put must each run in O(1) average time complexity.","Example 1:

Input
[""LFUCache"", ""put"", ""put"", ""get"", ""put"", ""get"", ""get"", ""put"", ""get"", ""get"", ""get""]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, 3, null, -1, 3, 4]

Explanation
// cnt(x) = the use counter for key x
// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)
LFUCache lfu = new LFUCache(2);
lfu.put(1, 1);   // cache=[1,_], cnt(1)=1
lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
lfu.get(1);      // return 1
                 // cache=[1,2], cnt(2)=1, cnt(1)=2
lfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.
                 // cache=[3,1], cnt(3)=1, cnt(1)=2
lfu.get(2);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,1], cnt(3)=2, cnt(1)=2
lfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.
                 // cache=[4,3], cnt(4)=1, cnt(3)=2
lfu.get(1);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,4], cnt(4)=1, cnt(3)=3
lfu.get(4);      // return 4
                 // cache=[4,3], cnt(4)=2, cnt(3)=3
 

Constraints:

1 <= capacity <= 104
0 <= key <= 105
0 <= value <= 109
At most 2 * 105 calls will be made to get and put.",Hard,,"Hash Table, Doubly Linked List, Desgin",,249.3K,564K,44.20%,89,,,,,,